diff --git a/BUILD.gn b/BUILD.gn
index ff313e6..b4b5163 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -274,11 +274,11 @@ group("both_gn_and_gyp") {
       "//content/test:content_perftests",
       "//content/test:content_unittests",
       "//device:device_unittests",
+      "//device/capture:capture_unittests",
       "//gpu:gpu_unittests",
       "//gpu/ipc/service:gpu_ipc_service_unittests",
       "//ipc:ipc_tests",
       "//media:media_unittests",
-      "//media/capture:capture_unittests",
       "//media/cast:cast_unittests",
       "//media/midi:midi_unittests",
       "//mojo",
@@ -1091,6 +1091,7 @@ if (is_win) {
       "//courgette:courgette_unittests",
       "//crypto:crypto_unittests",
       "//device:device_unittests",
+      "//device/capture:capture_unittests",
       "//extensions:extensions_browsertests",
       "//extensions:extensions_unittests",
       "//gin:gin_shell",
@@ -1101,7 +1102,6 @@ if (is_win) {
       "//ipc:ipc_tests",
       "//jingle:jingle_unittests",
       "//media:media_unittests",
-      "//media/capture:capture_unittests",
       "//media/cast:cast_unittests",
       "//media/midi:midi_unittests",
       "//mojo",
diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
index 22f6ce1..ca9d3f0 100644
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -153,10 +153,9 @@ android_library("chrome_java") {
     "//components/web_contents_delegate_android:web_contents_delegate_android_java",
     "//components/web_restrictions:web_restrictions_java",
     "//content/public/android:content_java",
+    "//device/capture:capture_java",
     "//device/geolocation:geolocation_java",
     "//media/base/android:media_java",
-    "//media/capture/content/android:screen_capture_java",
-    "//media/capture/video/android:capture_java",
     "//media/midi:midi_java",
     "//mojo/public/java:bindings",
     "//mojo/public/java:system",
diff --git a/content/DEPS b/content/DEPS
index 4bc4a3f..b02e3f1 100644
--- a/content/DEPS
+++ b/content/DEPS
@@ -34,7 +34,7 @@ include_rules = [
   "+grit/blink_resources.h",
   "+grit/content_strings.h",
 
-  "+dbus",
+  "+device/capture",
   "+gpu",
   "+media",
   "+mojo/common",
diff --git a/content/app/BUILD.gn b/content/app/BUILD.gn
index 116a1db..310e7dd 100644
--- a/content/app/BUILD.gn
+++ b/content/app/BUILD.gn
@@ -1,4 +1,4 @@
-# Copyright 2014 The Chromium Authors. All rights reserved.
+# Copyright 2014 The Chromium Authors. All rights rescontent/browser/BUILD.gnerved.
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
@@ -49,6 +49,7 @@ template("implement_content_app") {
       "//content/browser",
       "//content/child",
       "//device/bluetooth",
+      "//device/capture",
       "//device/gamepad",
       "//device/geolocation:device_geolocation",
       "//device/power_save_blocker",
@@ -56,7 +57,6 @@ template("implement_content_app") {
       "//device/vibration",
       "//gpu",
       "//media",
-      "//media/capture",
       "//media/midi",
       "//net",
       "//skia",
diff --git a/content/app/android/library_loader_hooks.cc b/content/app/android/library_loader_hooks.cc
index 9b441d9..29becfa 100644
--- a/content/app/android/library_loader_hooks.cc
+++ b/content/app/android/library_loader_hooks.cc
@@ -26,12 +26,12 @@
 #include "content/public/common/content_switches.h"
 #include "content/public/common/result_codes.h"
 #include "device/bluetooth/android/bluetooth_jni_registrar.h"
+#include "device/capture/content/android/screen_capture_jni_registrar.h"
+#include "device/capture/video/android/capture_jni_registrar.h"
 #include "device/gamepad/android/gamepad_jni_registrar.h"
 #include "device/geolocation/android/geolocation_jni_registrar.h"
 #include "device/usb/android/usb_jni_registrar.h"
 #include "media/base/android/media_jni_registrar.h"
-#include "media/capture/content/android/screen_capture_jni_registrar.h"
-#include "media/capture/video/android/capture_jni_registrar.h"
 #include "media/midi/midi_jni_registrar.h"
 #include "net/android/net_jni_registrar.h"
 #include "ui/android/ui_android_jni_registrar.h"
@@ -76,27 +76,27 @@ bool EnsureJniRegistered(JNIEnv* env) {
     if (!device::android::RegisterBluetoothJni(env))
       return false;
 
+    if (!device::RegisterCaptureJni(env))
+      return false;
+
     if (!device::android::RegisterGamepadJni(env))
       return false;
 
     if (!device::android::RegisterGeolocationJni(env))
       return false;
 
-    if (!device::android::RegisterUsbJni(env))
+    if (!device::RegisterScreenCaptureJni(env))
       return false;
 
-    if (!media::RegisterJni(env))
+    if (!device::android::RegisterUsbJni(env))
       return false;
 
-    if (!media::RegisterCaptureJni(env))
+    if (!media::RegisterJni(env))
       return false;
 
     if (!media::midi::RegisterJni(env))
       return false;
 
-    if (!media::RegisterScreenCaptureJni(env))
-      return false;
-
     if (!ui::RegisterUIAndroidJni(env))
       return false;
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index ceba43c..9259492e 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -62,6 +62,7 @@ source_set("browser") {
     "//crypto",
     "//device/battery",
     "//device/bluetooth",
+    "//device/capture",
     "//device/gamepad",
     "//device/geolocation:device_geolocation",
     "//device/geolocation/public/interfaces",
@@ -73,7 +74,6 @@ source_set("browser") {
     "//gpu/command_buffer/client:gles2_implementation",
     "//gpu/command_buffer/client:gles2_interface",
     "//media",
-    "//media/capture",
     "//media/gpu/ipc/client",
     "//media/midi",
     "//media/mojo/interfaces",
@@ -247,8 +247,8 @@ source_set("browser") {
 
   if (use_udev) {
     deps += [
+      "//device/capture",
       "//device/udev_linux",
-      "//media/capture",
     ]
   }
 
@@ -337,9 +337,8 @@ source_set("browser") {
     deps -= [ "//device/battery" ]
     deps += [
       "//content/public/android:jni",
+      "//device/capture:capture_java",
       "//media",
-      "//media/capture/content/android",
-      "//media/capture/video/android",
       "//media/mojo/interfaces",
       "//mojo/android:libsystem_java",
       "//ui/android",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 21c29ee..1962e4f 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -154,11 +154,11 @@
 #endif
 
 #if defined(OS_WIN)
-#include "media/capture/system_message_window_win.h"
+#include "device/capture/system_message_window_win.h"
 #elif defined(OS_LINUX) && defined(USE_UDEV)
-#include "media/capture/device_monitor_udev.h"
+#include "device/capture/device_monitor_udev.h"
 #elif defined(OS_MACOSX)
-#include "media/capture/device_monitor_mac.h"
+#include "device/capture/device_monitor_mac.h"
 #endif
 
 #if defined(OS_POSIX) && !defined(OS_MACOSX)
@@ -1277,12 +1277,12 @@ int BrowserMainLoop::BrowserThreadsStarted() {
   }
 
 #if defined(OS_WIN)
-  system_message_window_.reset(new media::SystemMessageWindowWin);
+  system_message_window_.reset(new device::SystemMessageWindowWin);
 #elif defined(OS_LINUX) && defined(USE_UDEV)
   device_monitor_linux_.reset(
-      new media::DeviceMonitorLinux(io_thread_->task_runner()));
+      new device::DeviceMonitorLinux(io_thread_->task_runner()));
 #elif defined(OS_MACOSX)
-  device_monitor_mac_.reset(new media::DeviceMonitorMac());
+  device_monitor_mac_.reset(new device::DeviceMonitorMac());
 #endif
 
 #if defined(OS_WIN)
diff --git a/content/browser/browser_main_loop.h b/content/browser/browser_main_loop.h
index d05d176..c0bf346 100644
--- a/content/browser/browser_main_loop.h
+++ b/content/browser/browser_main_loop.h
@@ -35,16 +35,18 @@ class TraceEventSystemStatsMonitor;
 }  // namespace trace_event
 }  // namespace base
 
-namespace media {
+namespace device {
 #if defined(OS_WIN)
 class SystemMessageWindowWin;
 #elif defined(OS_LINUX) && defined(USE_UDEV)
 class DeviceMonitorLinux;
-#endif
-class UserInputMonitor;
-#if defined(OS_MACOSX)
+#elif defined(OS_MACOSX)
 class DeviceMonitorMac;
 #endif
+}  // namespace device
+
+namespace media {
+class UserInputMonitor;
 namespace midi {
 class MidiManager;
 }  // namespace midi
@@ -281,11 +283,11 @@ class CONTENT_EXPORT BrowserMainLoop {
   std::unique_ptr<media::midi::MidiManager> midi_manager_;
 
 #if defined(OS_WIN)
-  std::unique_ptr<media::SystemMessageWindowWin> system_message_window_;
+  std::unique_ptr<device::SystemMessageWindowWin> system_message_window_;
 #elif defined(OS_LINUX) && defined(USE_UDEV)
-  std::unique_ptr<media::DeviceMonitorLinux> device_monitor_linux_;
+  std::unique_ptr<device::DeviceMonitorLinux> device_monitor_linux_;
 #elif defined(OS_MACOSX) && !defined(OS_IOS)
-  std::unique_ptr<media::DeviceMonitorMac> device_monitor_mac_;
+  std::unique_ptr<device::DeviceMonitorMac> device_monitor_mac_;
 #endif
 #if defined(USE_OZONE)
   std::unique_ptr<ui::ClientNativePixmapFactory> client_native_pixmap_factory_;
diff --git a/content/browser/media/capture/aura_window_capture_machine.cc b/content/browser/media/capture/aura_window_capture_machine.cc
index 392190e..733f995 100644
--- a/content/browser/media/capture/aura_window_capture_machine.cc
+++ b/content/browser/media/capture/aura_window_capture_machine.cc
@@ -15,11 +15,11 @@
 #include "content/browser/compositor/image_transport_factory.h"
 #include "content/browser/media/capture/desktop_capture_device_uma_types.h"
 #include "content/public/browser/browser_thread.h"
+#include "device/capture/content/thread_safe_capture_oracle.h"
+#include "device/capture/content/video_capture_oracle.h"
 #include "device/power_save_blocker/power_save_blocker.h"
 #include "media/base/video_capture_types.h"
 #include "media/base/video_util.h"
-#include "media/capture/content/thread_safe_capture_oracle.h"
-#include "media/capture/content/video_capture_oracle.h"
 #include "skia/ext/image_operations.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "ui/aura/client/screen_position_client.h"
@@ -43,7 +43,7 @@ AuraWindowCaptureMachine::AuraWindowCaptureMachine()
 AuraWindowCaptureMachine::~AuraWindowCaptureMachine() {}
 
 void AuraWindowCaptureMachine::Start(
-  const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+  const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
   const media::VideoCaptureParams& params,
   const base::Callback<void(bool)> callback) {
   // Starts the capture machine asynchronously.
@@ -58,7 +58,7 @@ void AuraWindowCaptureMachine::Start(
 }
 
 bool AuraWindowCaptureMachine::InternalStart(
-    const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+    const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
     const media::VideoCaptureParams& params) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
@@ -170,18 +170,18 @@ void AuraWindowCaptureMachine::Capture(base::TimeTicks event_time) {
     return;
 
   scoped_refptr<media::VideoFrame> frame;
-  media::ThreadSafeCaptureOracle::CaptureFrameCallback capture_frame_cb;
+  device::ThreadSafeCaptureOracle::CaptureFrameCallback capture_frame_cb;
 
   // TODO(miu): Need to fix this so the compositor is providing the presentation
   // timestamps and damage regions, to leverage the frame timestamp rewriting
   // logic.  http://crbug.com/492839
   const base::TimeTicks start_time = base::TimeTicks::Now();
-  media::VideoCaptureOracle::Event event;
+  device::VideoCaptureOracle::Event event;
   if (event_time.is_null()) {
-    event = media::VideoCaptureOracle::kActiveRefreshRequest;
+    event = device::VideoCaptureOracle::kActiveRefreshRequest;
     event_time = start_time;
   } else {
-    event = media::VideoCaptureOracle::kCompositorUpdate;
+    event = device::VideoCaptureOracle::kCompositorUpdate;
   }
   if (oracle_proxy_->ObserveEventAndDecideCapture(
           event, gfx::Rect(), event_time, &frame, &capture_frame_cb)) {
@@ -320,7 +320,7 @@ bool AuraWindowCaptureMachine::ProcessCopyOutputResponse(
 }
 
 using CaptureFrameCallback =
-    media::ThreadSafeCaptureOracle::CaptureFrameCallback;
+    device::ThreadSafeCaptureOracle::CaptureFrameCallback;
 
 void AuraWindowCaptureMachine::CopyOutputFinishedForVideo(
     base::WeakPtr<AuraWindowCaptureMachine> machine,
diff --git a/content/browser/media/capture/aura_window_capture_machine.h b/content/browser/media/capture/aura_window_capture_machine.h
index 848c325..72618d8 100644
--- a/content/browser/media/capture/aura_window_capture_machine.h
+++ b/content/browser/media/capture/aura_window_capture_machine.h
@@ -10,7 +10,7 @@
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "content/browser/media/capture/cursor_renderer_aura.h"
-#include "media/capture/content/screen_capture_device_core.h"
+#include "device/capture/content/screen_capture_device_core.h"
 #include "ui/aura/window.h"
 #include "ui/aura/window_observer.h"
 #include "ui/base/cursor/cursors_aura.h"
@@ -31,16 +31,15 @@ class ReadbackYUVInterface;
 
 namespace content {
 
-class AuraWindowCaptureMachine
-    : public media::VideoCaptureMachine,
-      public aura::WindowObserver,
-      public ui::CompositorAnimationObserver {
+class AuraWindowCaptureMachine : public device::VideoCaptureMachine,
+                                 public aura::WindowObserver,
+                                 public ui::CompositorAnimationObserver {
  public:
   AuraWindowCaptureMachine();
   ~AuraWindowCaptureMachine() override;
 
   // VideoCaptureMachine overrides.
-  void Start(const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+  void Start(const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
              const media::VideoCaptureParams& params,
              const base::Callback<void(bool)> callback) override;
   void Stop(const base::Closure& callback) override;
@@ -64,7 +63,7 @@ class AuraWindowCaptureMachine
 
  private:
   bool InternalStart(
-      const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+      const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
       const media::VideoCaptureParams& params);
   void InternalStop(const base::Closure& callback);
 
@@ -76,7 +75,7 @@ class AuraWindowCaptureMachine
   void UpdateCaptureSize();
 
   using CaptureFrameCallback =
-      media::ThreadSafeCaptureOracle::CaptureFrameCallback;
+      device::ThreadSafeCaptureOracle::CaptureFrameCallback;
 
   // Response callback for cc::Layer::RequestCopyOfOutput().
   void DidCopyOutput(scoped_refptr<media::VideoFrame> video_frame,
@@ -110,7 +109,7 @@ class AuraWindowCaptureMachine
   bool screen_capture_;
 
   // Makes all the decisions about which frames to copy, and how.
-  scoped_refptr<media::ThreadSafeCaptureOracle> oracle_proxy_;
+  scoped_refptr<device::ThreadSafeCaptureOracle> oracle_proxy_;
 
   // The capture parameters for this capture.
   media::VideoCaptureParams capture_params_;
diff --git a/content/browser/media/capture/desktop_capture_device.cc b/content/browser/media/capture/desktop_capture_device.cc
index efd4e31..a090609 100644
--- a/content/browser/media/capture/desktop_capture_device.cc
+++ b/content/browser/media/capture/desktop_capture_device.cc
@@ -22,9 +22,9 @@
 #include "content/browser/media/capture/desktop_capture_device_uma_types.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/desktop_media_id.h"
+#include "device/capture/content/capture_resolution_chooser.h"
 #include "device/power_save_blocker/power_save_blocker.h"
 #include "media/base/video_util.h"
-#include "media/capture/content/capture_resolution_chooser.h"
 #include "third_party/libyuv/include/libyuv/scale_argb.h"
 #include "third_party/webrtc/modules/desktop_capture/cropping_window_capturer.h"
 #include "third_party/webrtc/modules/desktop_capture/desktop_and_cursor_composer.h"
@@ -107,7 +107,7 @@ class DesktopCaptureDevice::Core : public webrtc::DesktopCapturer::Callback {
   webrtc::DesktopSize previous_frame_size_;
 
   // Determines the size of frames to deliver to the |client_|.
-  std::unique_ptr<media::CaptureResolutionChooser> resolution_chooser_;
+  std::unique_ptr<device::CaptureResolutionChooser> resolution_chooser_;
 
   // DesktopFrame into which captured frames are down-scaled and/or letterboxed,
   // depending upon the caller's requested capture capabilities. If frames can
@@ -169,7 +169,7 @@ void DesktopCaptureDevice::Core::AllocateAndStart(
 
   client_ = std::move(client);
   requested_frame_rate_ = params.requested_format.frame_rate;
-  resolution_chooser_.reset(new media::CaptureResolutionChooser(
+  resolution_chooser_.reset(new device::CaptureResolutionChooser(
       params.requested_format.frame_size,
       params.resolution_change_policy));
 
@@ -357,7 +357,7 @@ void DesktopCaptureDevice::Core::DoCapture() {
 }
 
 // static
-std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDevice::Create(
+std::unique_ptr<device::VideoCaptureDevice> DesktopCaptureDevice::Create(
     const DesktopMediaID& source) {
   webrtc::DesktopCaptureOptions options =
       webrtc::DesktopCaptureOptions::CreateDefault();
@@ -401,7 +401,7 @@ std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDevice::Create(
         default: { NOTREACHED(); }
   }
 
-  std::unique_ptr<media::VideoCaptureDevice> result;
+  std::unique_ptr<device::VideoCaptureDevice> result;
   if (capturer)
     result.reset(new DesktopCaptureDevice(std::move(capturer), source.type));
 
diff --git a/content/browser/media/capture/desktop_capture_device.h b/content/browser/media/capture/desktop_capture_device.h
index 2cb77e6..2133cdb 100644
--- a/content/browser/media/capture/desktop_capture_device.h
+++ b/content/browser/media/capture/desktop_capture_device.h
@@ -12,7 +12,7 @@
 #include "base/threading/thread.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/desktop_media_id.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 #include "ui/gfx/native_widget_types.h"
 
 namespace base {
@@ -29,12 +29,12 @@ namespace content {
 // DesktopCaptureDevice implements VideoCaptureDevice for screens and windows.
 // It's essentially an adapter between webrtc::DesktopCapturer and
 // VideoCaptureDevice.
-class CONTENT_EXPORT DesktopCaptureDevice : public media::VideoCaptureDevice {
+class CONTENT_EXPORT DesktopCaptureDevice : public device::VideoCaptureDevice {
  public:
   // Creates capturer for the specified |source| and then creates
   // DesktopCaptureDevice for it. May return NULL in case of a failure (e.g. if
   // requested window was destroyed).
-  static std::unique_ptr<media::VideoCaptureDevice> Create(
+  static std::unique_ptr<device::VideoCaptureDevice> Create(
       const DesktopMediaID& source);
 
   ~DesktopCaptureDevice() override;
diff --git a/content/browser/media/capture/desktop_capture_device_aura.cc b/content/browser/media/capture/desktop_capture_device_aura.cc
index ac8929b..3d6cde7 100644
--- a/content/browser/media/capture/desktop_capture_device_aura.cc
+++ b/content/browser/media/capture/desktop_capture_device_aura.cc
@@ -31,7 +31,7 @@ void SetCaptureSource(AuraWindowCaptureMachine* machine,
 DesktopCaptureDeviceAura::DesktopCaptureDeviceAura(
     const DesktopMediaID& source) {
   AuraWindowCaptureMachine* machine = new AuraWindowCaptureMachine();
-  core_.reset(new media::ScreenCaptureDeviceCore(base::WrapUnique(machine)));
+  core_.reset(new device::ScreenCaptureDeviceCore(base::WrapUnique(machine)));
   // |core_| owns |machine| and deletes it on UI thread so passing the raw
   // pointer to the UI thread is safe here.
   BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
@@ -43,11 +43,11 @@ DesktopCaptureDeviceAura::~DesktopCaptureDeviceAura() {
 }
 
 // static
-std::unique_ptr<media::VideoCaptureDevice> DesktopCaptureDeviceAura::Create(
+std::unique_ptr<device::VideoCaptureDevice> DesktopCaptureDeviceAura::Create(
     const DesktopMediaID& source) {
   if (source.aura_id == DesktopMediaID::kNullId)
     return nullptr;
-  return std::unique_ptr<media::VideoCaptureDevice>(
+  return std::unique_ptr<device::VideoCaptureDevice>(
       new DesktopCaptureDeviceAura(source));
 }
 
diff --git a/content/browser/media/capture/desktop_capture_device_aura.h b/content/browser/media/capture/desktop_capture_device_aura.h
index 73a7d53..f2b49d3 100644
--- a/content/browser/media/capture/desktop_capture_device_aura.h
+++ b/content/browser/media/capture/desktop_capture_device_aura.h
@@ -11,8 +11,8 @@
 #include "base/macros.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/desktop_media_id.h"
-#include "media/capture/content/screen_capture_device_core.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/content/screen_capture_device_core.h"
+#include "device/capture/video/video_capture_device.h"
 
 namespace aura {
 class Window;
@@ -22,11 +22,11 @@ namespace content {
 
 // An implementation of VideoCaptureDevice that mirrors an Aura window.
 class CONTENT_EXPORT DesktopCaptureDeviceAura
-    : public media::VideoCaptureDevice {
+    : public device::VideoCaptureDevice {
  public:
   // Creates a VideoCaptureDevice for the Aura desktop.  If |source| does not
   // reference a registered aura window, returns nullptr instead.
-  static std::unique_ptr<media::VideoCaptureDevice> Create(
+  static std::unique_ptr<device::VideoCaptureDevice> Create(
       const DesktopMediaID& source);
 
   ~DesktopCaptureDeviceAura() override;
@@ -40,7 +40,7 @@ class CONTENT_EXPORT DesktopCaptureDeviceAura
  private:
   explicit DesktopCaptureDeviceAura(const DesktopMediaID& source);
 
-  std::unique_ptr<media::ScreenCaptureDeviceCore> core_;
+  std::unique_ptr<device::ScreenCaptureDeviceCore> core_;
 
   DISALLOW_COPY_AND_ASSIGN(DesktopCaptureDeviceAura);
 };
diff --git a/content/browser/media/capture/desktop_capture_device_aura_unittest.cc b/content/browser/media/capture/desktop_capture_device_aura_unittest.cc
index cca139f..fa7effa 100644
--- a/content/browser/media/capture/desktop_capture_device_aura_unittest.cc
+++ b/content/browser/media/capture/desktop_capture_device_aura_unittest.cc
@@ -39,7 +39,7 @@ namespace {
 
 const int kFrameRate = 30;
 
-class MockDeviceClient : public media::VideoCaptureDevice::Client {
+class MockDeviceClient : public device::VideoCaptureDevice::Client {
  public:
   MOCK_METHOD6(OnIncomingCapturedData,
                void(const uint8_t* data,
@@ -141,7 +141,7 @@ class DesktopCaptureDeviceAuraTest : public testing::Test {
 };
 
 TEST_F(DesktopCaptureDeviceAuraTest, StartAndStop) {
-  std::unique_ptr<media::VideoCaptureDevice> capture_device =
+  std::unique_ptr<device::VideoCaptureDevice> capture_device =
       DesktopCaptureDeviceAura::Create(
           content::DesktopMediaID::RegisterAuraWindow(
               content::DesktopMediaID::TYPE_SCREEN, root_window()));
diff --git a/content/browser/media/capture/desktop_capture_device_unittest.cc b/content/browser/media/capture/desktop_capture_device_unittest.cc
index 63f655f..5210e76 100644
--- a/content/browser/media/capture/desktop_capture_device_unittest.cc
+++ b/content/browser/media/capture/desktop_capture_device_unittest.cc
@@ -58,7 +58,7 @@ const uint8_t kFakePixelValue = 1;
 // frame test.
 const uint8_t kFakePixelValueFirst = 2;
 
-class MockDeviceClient : public media::VideoCaptureDevice::Client {
+class MockDeviceClient : public device::VideoCaptureDevice::Client {
  public:
   MOCK_METHOD6(OnIncomingCapturedData,
                void(const uint8_t* data,
diff --git a/content/browser/media/capture/image_capture_impl.cc b/content/browser/media/capture/image_capture_impl.cc
index f1832e7..b24d460 100644
--- a/content/browser/media/capture/image_capture_impl.cc
+++ b/content/browser/media/capture/image_capture_impl.cc
@@ -12,8 +12,8 @@
 #include "content/browser/renderer_host/media/video_capture_manager.h"
 #include "content/common/media/media_stream_options.h"
 #include "content/public/browser/browser_thread.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/base/bind_to_current_loop.h"
-#include "media/capture/video/video_capture_device.h"
 
 namespace content {
 
@@ -68,7 +68,7 @@ void RunFailedTakePhotoCallback(const ImageCaptureImpl::TakePhotoCallback& cb) {
 void GetCapabilitiesOnIOThread(
     const std::string& source_id,
     MediaStreamManager* media_stream_manager,
-    media::ScopedResultCallback<ImageCaptureImpl::GetCapabilitiesCallback>
+    device::ScopedResultCallback<ImageCaptureImpl::GetCapabilitiesCallback>
         callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
@@ -85,7 +85,7 @@ void SetOptionsOnIOThread(
     const std::string& source_id,
     MediaStreamManager* media_stream_manager,
     media::mojom::PhotoSettingsPtr settings,
-    media::ScopedResultCallback<ImageCaptureImpl::SetOptionsCallback>
+    device::ScopedResultCallback<ImageCaptureImpl::SetOptionsCallback>
         callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
@@ -101,7 +101,8 @@ void SetOptionsOnIOThread(
 void TakePhotoOnIOThread(
     const std::string& source_id,
     MediaStreamManager* media_stream_manager,
-    media::ScopedResultCallback<ImageCaptureImpl::TakePhotoCallback> callback) {
+    device::ScopedResultCallback<ImageCaptureImpl::TakePhotoCallback>
+        callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   const int session_id =
@@ -129,7 +130,7 @@ void ImageCaptureImpl::GetCapabilities(
     const GetCapabilitiesCallback& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
-  media::ScopedResultCallback<GetCapabilitiesCallback> scoped_callback(
+  device::ScopedResultCallback<GetCapabilitiesCallback> scoped_callback(
       base::Bind(&RunGetCapabilitiesCallbackOnUIThread, callback),
       media::BindToCurrentLoop(base::Bind(&RunFailedGetCapabilitiesCallback)));
 
@@ -145,7 +146,7 @@ void ImageCaptureImpl::SetOptions(const std::string& source_id,
                                   const SetOptionsCallback& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
-  media::ScopedResultCallback<SetOptionsCallback> scoped_callback(
+  device::ScopedResultCallback<SetOptionsCallback> scoped_callback(
       base::Bind(&RunSetOptionsCallbackOnUIThread, callback),
       media::BindToCurrentLoop(base::Bind(&RunFailedSetOptionsCallback)));
 
@@ -160,7 +161,7 @@ void ImageCaptureImpl::TakePhoto(const std::string& source_id,
                                  const TakePhotoCallback& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
-  media::ScopedResultCallback<TakePhotoCallback> scoped_callback(
+  device::ScopedResultCallback<TakePhotoCallback> scoped_callback(
       base::Bind(&RunTakePhotoCallbackOnUIThread, callback),
       media::BindToCurrentLoop(base::Bind(&RunFailedTakePhotoCallback)));
 
diff --git a/content/browser/media/capture/screen_capture_device_android.cc b/content/browser/media/capture/screen_capture_device_android.cc
index 077542e..56384de 100644
--- a/content/browser/media/capture/screen_capture_device_android.cc
+++ b/content/browser/media/capture/screen_capture_device_android.cc
@@ -6,12 +6,12 @@
 
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
-#include "media/capture/content/android/screen_capture_machine_android.h"
+#include "device/capture/content/android/screen_capture_machine_android.h"
 
 namespace content {
 
 ScreenCaptureDeviceAndroid::ScreenCaptureDeviceAndroid()
-    : core_(base::WrapUnique(new media::ScreenCaptureMachineAndroid())) {}
+    : core_(base::WrapUnique(new device::ScreenCaptureMachineAndroid())) {}
 
 ScreenCaptureDeviceAndroid::~ScreenCaptureDeviceAndroid() {
   DVLOG(2) << "ScreenCaptureDeviceAndroid@" << this << " destroying.";
diff --git a/content/browser/media/capture/screen_capture_device_android.h b/content/browser/media/capture/screen_capture_device_android.h
index 6c8e687..66dd0fc 100644
--- a/content/browser/media/capture/screen_capture_device_android.h
+++ b/content/browser/media/capture/screen_capture_device_android.h
@@ -7,15 +7,15 @@
 
 #include <memory>
 
-#include "media/capture/content/screen_capture_device_core.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/content/screen_capture_device_core.h"
+#include "device/capture/video/video_capture_device.h"
 
 namespace content {
 
-// ScreenCaptureDeviceAndroid is a forwarder to media::ScreenCaptureDeviceCore
+// ScreenCaptureDeviceAndroid is a forwarder to device::ScreenCaptureDeviceCore
 // while keeping the Power Saving from kicking in between AllocateAndStart() and
 // StopAndDeAllocate().
-class ScreenCaptureDeviceAndroid : public media::VideoCaptureDevice {
+class ScreenCaptureDeviceAndroid : public device::VideoCaptureDevice {
  public:
   ScreenCaptureDeviceAndroid();
   ~ScreenCaptureDeviceAndroid() override;
@@ -27,7 +27,7 @@ class ScreenCaptureDeviceAndroid : public media::VideoCaptureDevice {
   void RequestRefreshFrame() override;
 
  private:
-  media::ScreenCaptureDeviceCore core_;
+  device::ScreenCaptureDeviceCore core_;
 
   DISALLOW_COPY_AND_ASSIGN(ScreenCaptureDeviceAndroid);
 };
diff --git a/content/browser/media/capture/web_contents_video_capture_device.cc b/content/browser/media/capture/web_contents_video_capture_device.cc
index 0733a1f..15da56e 100644
--- a/content/browser/media/capture/web_contents_video_capture_device.cc
+++ b/content/browser/media/capture/web_contents_video_capture_device.cc
@@ -80,13 +80,13 @@
 #include "content/public/browser/render_widget_host_view_frame_subscriber.h"
 #include "content/public/browser/web_contents.h"
 #include "content/public/browser/web_contents_media_capture_id.h"
+#include "device/capture/content/screen_capture_device_core.h"
+#include "device/capture/content/thread_safe_capture_oracle.h"
+#include "device/capture/content/video_capture_oracle.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/base/video_capture_types.h"
 #include "media/base/video_frame_metadata.h"
 #include "media/base/video_util.h"
-#include "media/capture/content/screen_capture_device_core.h"
-#include "media/capture/content/thread_safe_capture_oracle.h"
-#include "media/capture/content/video_capture_oracle.h"
 #include "skia/ext/image_operations.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkColor.h"
@@ -135,8 +135,8 @@ class VideoFrameDeliveryLog {
 // with RenderWidgetHostViewFrameSubscriber. We create one per event type.
 class FrameSubscriber : public RenderWidgetHostViewFrameSubscriber {
  public:
-  FrameSubscriber(media::VideoCaptureOracle::Event event_type,
-                  const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle,
+  FrameSubscriber(device::VideoCaptureOracle::Event event_type,
+                  const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle,
                   VideoFrameDeliveryLog* delivery_log,
                   base::WeakPtr<content::CursorRenderer> cursor_renderer,
                   base::WeakPtr<content::WindowActivityTracker> tracker)
@@ -156,7 +156,7 @@ class FrameSubscriber : public RenderWidgetHostViewFrameSubscriber {
 
   static void DidCaptureFrame(
       base::WeakPtr<FrameSubscriber> frame_subscriber_,
-      const media::ThreadSafeCaptureOracle::CaptureFrameCallback&
+      const device::ThreadSafeCaptureOracle::CaptureFrameCallback&
           capture_frame_cb,
       const scoped_refptr<media::VideoFrame>& frame,
       base::TimeTicks timestamp,
@@ -166,8 +166,8 @@ class FrameSubscriber : public RenderWidgetHostViewFrameSubscriber {
   bool IsUserInteractingWithContent();
 
  private:
-  const media::VideoCaptureOracle::Event event_type_;
-  scoped_refptr<media::ThreadSafeCaptureOracle> oracle_proxy_;
+  const device::VideoCaptureOracle::Event event_type_;
+  scoped_refptr<device::ThreadSafeCaptureOracle> oracle_proxy_;
   VideoFrameDeliveryLog* const delivery_log_;
   // We need a weak pointer since FrameSubscriber is owned externally and
   // may outlive the cursor renderer.
@@ -204,7 +204,7 @@ class ContentCaptureSubscription {
   // work.
   ContentCaptureSubscription(
       const RenderWidgetHost& source,
-      const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+      const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
       const CaptureCallback& capture_callback);
   ~ContentCaptureSubscription();
 
@@ -253,7 +253,7 @@ void RenderVideoFrame(
 
 // Renews capture subscriptions based on feedback from WebContentsTracker, and
 // also executes copying of the backing store on the UI BrowserThread.
-class WebContentsCaptureMachine : public media::VideoCaptureMachine {
+class WebContentsCaptureMachine : public device::VideoCaptureMachine {
  public:
   WebContentsCaptureMachine(int render_process_id,
                             int main_render_frame_id,
@@ -261,7 +261,7 @@ class WebContentsCaptureMachine : public media::VideoCaptureMachine {
   ~WebContentsCaptureMachine() override;
 
   // VideoCaptureMachine overrides.
-  void Start(const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+  void Start(const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
              const media::VideoCaptureParams& params,
              const base::Callback<void(bool)> callback) override;
   void Stop(const base::Closure& callback) override;
@@ -282,7 +282,7 @@ class WebContentsCaptureMachine : public media::VideoCaptureMachine {
 
  private:
   bool InternalStart(
-      const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+      const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
       const media::VideoCaptureParams& params);
   void InternalStop(const base::Closure& callback);
   void InternalMaybeCaptureForRefresh();
@@ -333,7 +333,7 @@ class WebContentsCaptureMachine : public media::VideoCaptureMachine {
   std::unique_ptr<base::Thread> render_thread_;
 
   // Makes all the decisions about which frames to copy, and how.
-  scoped_refptr<media::ThreadSafeCaptureOracle> oracle_proxy_;
+  scoped_refptr<device::ThreadSafeCaptureOracle> oracle_proxy_;
 
   // Video capture parameters that this machine is started with.
   media::VideoCaptureParams capture_params_;
@@ -360,7 +360,7 @@ bool FrameSubscriber::ShouldCaptureFrame(
   TRACE_EVENT1("gpu.capture", "FrameSubscriber::ShouldCaptureFrame", "instance",
                this);
 
-  media::ThreadSafeCaptureOracle::CaptureFrameCallback capture_frame_cb;
+  device::ThreadSafeCaptureOracle::CaptureFrameCallback capture_frame_cb;
 
   bool oracle_decision = oracle_proxy_->ObserveEventAndDecideCapture(
       event_type_, damage_rect, present_time, storage, &capture_frame_cb);
@@ -376,7 +376,7 @@ bool FrameSubscriber::ShouldCaptureFrame(
 
 void FrameSubscriber::DidCaptureFrame(
     base::WeakPtr<FrameSubscriber> frame_subscriber_,
-    const media::ThreadSafeCaptureOracle::CaptureFrameCallback&
+    const device::ThreadSafeCaptureOracle::CaptureFrameCallback&
         capture_frame_cb,
     const scoped_refptr<media::VideoFrame>& frame,
     base::TimeTicks timestamp,
@@ -425,7 +425,7 @@ bool FrameSubscriber::IsUserInteractingWithContent() {
 
 ContentCaptureSubscription::ContentCaptureSubscription(
     const RenderWidgetHost& source,
-    const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+    const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
     const CaptureCallback& capture_callback)
     : render_process_id_(source.GetProcess()->GetID()),
       render_widget_id_(source.GetRoutingID()),
@@ -442,14 +442,14 @@ ContentCaptureSubscription::ContentCaptureSubscription(
   }
 #endif
   refresh_subscriber_.reset(new FrameSubscriber(
-      media::VideoCaptureOracle::kActiveRefreshRequest, oracle_proxy,
+      device::VideoCaptureOracle::kActiveRefreshRequest, oracle_proxy,
       &delivery_log_,
       cursor_renderer_ ? cursor_renderer_->GetWeakPtr()
                        : base::WeakPtr<CursorRenderer>(),
       window_activity_tracker_ ? window_activity_tracker_->GetWeakPtr()
                                : base::WeakPtr<WindowActivityTracker>()));
   mouse_activity_subscriber_.reset(new FrameSubscriber(
-      media::VideoCaptureOracle::kMouseCursorUpdate, oracle_proxy,
+      device::VideoCaptureOracle::kMouseCursorUpdate, oracle_proxy,
       &delivery_log_, cursor_renderer_ ? cursor_renderer_->GetWeakPtr()
                                        : base::WeakPtr<CursorRenderer>(),
       window_activity_tracker_ ? window_activity_tracker_->GetWeakPtr()
@@ -460,7 +460,7 @@ ContentCaptureSubscription::ContentCaptureSubscription(
   if (view) {
     std::unique_ptr<RenderWidgetHostViewFrameSubscriber> subscriber(
         new FrameSubscriber(
-            media::VideoCaptureOracle::kCompositorUpdate, oracle_proxy,
+            device::VideoCaptureOracle::kCompositorUpdate, oracle_proxy,
             &delivery_log_, cursor_renderer_ ? cursor_renderer_->GetWeakPtr()
                                              : base::WeakPtr<CursorRenderer>(),
             window_activity_tracker_ ? window_activity_tracker_->GetWeakPtr()
@@ -632,7 +632,7 @@ bool WebContentsCaptureMachine::IsStarted() const {
 }
 
 void WebContentsCaptureMachine::Start(
-    const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+    const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
     const media::VideoCaptureParams& params,
     const base::Callback<void(bool)> callback) {
   // Starts the capture machine asynchronously.
@@ -644,7 +644,7 @@ void WebContentsCaptureMachine::Start(
 }
 
 bool WebContentsCaptureMachine::InternalStart(
-    const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+    const scoped_refptr<device::ThreadSafeCaptureOracle>& oracle_proxy,
     const media::VideoCaptureParams& params) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(!IsStarted());
@@ -939,8 +939,8 @@ WebContentsVideoCaptureDevice::WebContentsVideoCaptureDevice(
     int render_process_id,
     int main_render_frame_id,
     bool enable_auto_throttling)
-    : core_(new media::ScreenCaptureDeviceCore(
-          std::unique_ptr<media::VideoCaptureMachine>(
+    : core_(new device::ScreenCaptureDeviceCore(
+          std::unique_ptr<device::VideoCaptureMachine>(
               new WebContentsCaptureMachine(render_process_id,
                                             main_render_frame_id,
                                             enable_auto_throttling)))) {}
@@ -950,7 +950,7 @@ WebContentsVideoCaptureDevice::~WebContentsVideoCaptureDevice() {
 }
 
 // static
-media::VideoCaptureDevice* WebContentsVideoCaptureDevice::Create(
+device::VideoCaptureDevice* WebContentsVideoCaptureDevice::Create(
     const std::string& device_id) {
   // Parse device_id into render_process_id and main_render_frame_id.
   int render_process_id = -1;
diff --git a/content/browser/media/capture/web_contents_video_capture_device.h b/content/browser/media/capture/web_contents_video_capture_device.h
index ea92b3b..4fd6808 100644
--- a/content/browser/media/capture/web_contents_video_capture_device.h
+++ b/content/browser/media/capture/web_contents_video_capture_device.h
@@ -10,8 +10,8 @@
 
 #include "base/macros.h"
 #include "content/common/content_export.h"
-#include "media/capture/content/screen_capture_device_core.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/content/screen_capture_device_core.h"
+#include "device/capture/video/video_capture_device.h"
 
 namespace content {
 
@@ -26,16 +26,16 @@ namespace content {
 // WebContents instance.  As the RenderFrameHost tree mutates (e.g., due to page
 // navigations, or crashes/reloads), capture will continue without interruption.
 class CONTENT_EXPORT WebContentsVideoCaptureDevice
-    : public media::VideoCaptureDevice {
+    : public device::VideoCaptureDevice {
  public:
   // Create a WebContentsVideoCaptureDevice instance from the given
   // |device_id|.  Returns NULL if |device_id| is invalid.
-  static media::VideoCaptureDevice* Create(const std::string& device_id);
+  static device::VideoCaptureDevice* Create(const std::string& device_id);
 
   ~WebContentsVideoCaptureDevice() override;
 
   // VideoCaptureDevice implementation.
-  void AllocateAndStart(const media::VideoCaptureParams& params,
+  void AllocateAndStart(const device::VideoCaptureParams& params,
                         std::unique_ptr<Client> client) override;
   void RequestRefreshFrame() override;
   void StopAndDeAllocate() override;
@@ -46,7 +46,7 @@ class CONTENT_EXPORT WebContentsVideoCaptureDevice
       int main_render_frame_id,
       bool enable_auto_throttling);
 
-  const std::unique_ptr<media::ScreenCaptureDeviceCore> core_;
+  const std::unique_ptr<device::ScreenCaptureDeviceCore> core_;
 
   DISALLOW_COPY_AND_ASSIGN(WebContentsVideoCaptureDevice);
 };
diff --git a/content/browser/media/capture/web_contents_video_capture_device_unittest.cc b/content/browser/media/capture/web_contents_video_capture_device_unittest.cc
index 54e1633..4d6cd18 100644
--- a/content/browser/media/capture/web_contents_video_capture_device_unittest.cc
+++ b/content/browser/media/capture/web_contents_video_capture_device_unittest.cc
@@ -325,7 +325,7 @@ class CaptureTestRenderViewHostFactory : public RenderViewHostFactory {
 
 // A stub consumer of captured video frames, which checks the output of
 // WebContentsVideoCaptureDevice.
-class StubClient : public media::VideoCaptureDevice::Client {
+class StubClient : public device::VideoCaptureDevice::Client {
  public:
   StubClient(
       const base::Callback<void(SkColor, const gfx::Size&)>& report_callback,
@@ -346,7 +346,7 @@ class StubClient : public media::VideoCaptureDevice::Client {
 
   MOCK_METHOD0(DoOnIncomingCapturedBuffer, void(void));
 
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>
   ReserveOutputBuffer(const gfx::Size& dimensions,
                       media::VideoPixelFormat format,
                       media::VideoPixelStorage storage) override {
@@ -357,7 +357,7 @@ class StubClient : public media::VideoCaptureDevice::Client {
     if (buffer_id == VideoCaptureBufferPool::kInvalidId)
       return NULL;
 
-    return std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>(
+    return std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>(
         new AutoReleaseBuffer(
             buffer_pool_, buffer_pool_->GetBufferHandle(buffer_id), buffer_id));
   }
@@ -398,7 +398,7 @@ class StubClient : public media::VideoCaptureDevice::Client {
         frame->visible_rect().size());
   }
 
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>
   ResurrectLastOutputBuffer(const gfx::Size& dimensions,
                             media::VideoPixelFormat format,
                             media::VideoPixelStorage storage) override {
@@ -407,7 +407,7 @@ class StubClient : public media::VideoCaptureDevice::Client {
         buffer_pool_->ResurrectLastForProducer(dimensions, format, storage);
     if (buffer_id == VideoCaptureBufferPool::kInvalidId)
       return nullptr;
-    return std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>(
+    return std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>(
         new AutoReleaseBuffer(
             buffer_pool_, buffer_pool_->GetBufferHandle(buffer_id), buffer_id));
   }
@@ -420,7 +420,7 @@ class StubClient : public media::VideoCaptureDevice::Client {
   double GetBufferPoolUtilization() const override { return 0.0; }
 
  private:
-  class AutoReleaseBuffer : public media::VideoCaptureDevice::Client::Buffer {
+  class AutoReleaseBuffer : public device::VideoCaptureDevice::Client::Buffer {
    public:
     AutoReleaseBuffer(
         const scoped_refptr<VideoCaptureBufferPool>& pool,
@@ -474,7 +474,7 @@ class StubClientObserver {
 
   virtual ~StubClientObserver() {}
 
-  std::unique_ptr<media::VideoCaptureDevice::Client> PassClient() {
+  std::unique_ptr<device::VideoCaptureDevice::Client> PassClient() {
     return std::move(client_);
   }
 
@@ -656,7 +656,7 @@ class MAYBE_WebContentsVideoCaptureDeviceTest : public testing::Test {
   // Accessors.
   CaptureTestSourceController* source() { return &controller_; }
   WebContents* web_contents() const { return web_contents_.get(); }
-  media::VideoCaptureDevice* device() { return device_.get(); }
+  device::VideoCaptureDevice* device() { return device_.get(); }
 
   // Returns the device scale factor of the capture target's native view.  This
   // is necessary because, architecturally, the TestScreen implementation is
@@ -747,7 +747,7 @@ class MAYBE_WebContentsVideoCaptureDeviceTest : public testing::Test {
 
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
-        base::Bind(&media::VideoCaptureDevice::RequestRefreshFrame,
+        base::Bind(&device::VideoCaptureDevice::RequestRefreshFrame,
                    base::Unretained(device_.get())));
   }
 
@@ -780,7 +780,7 @@ class MAYBE_WebContentsVideoCaptureDeviceTest : public testing::Test {
   std::unique_ptr<WebContents> web_contents_;
 
   // Finally, the WebContentsVideoCaptureDevice under test.
-  std::unique_ptr<media::VideoCaptureDevice> device_;
+  std::unique_ptr<device::VideoCaptureDevice> device_;
 
   TestBrowserThreadBundle thread_bundle_;
 };
diff --git a/content/browser/media/media_internals.cc b/content/browser/media/media_internals.cc
index 3ef8673..80b1ebd 100644
--- a/content/browser/media/media_internals.cc
+++ b/content/browser/media/media_internals.cc
@@ -600,7 +600,7 @@ void MediaInternals::SendVideoCaptureDeviceCapabilities() {
 }
 
 void MediaInternals::UpdateVideoCaptureDeviceCapabilities(
-    const std::vector<std::tuple<media::VideoCaptureDeviceDescriptor,
+    const std::vector<std::tuple<device::VideoCaptureDeviceDescriptor,
                                  media::VideoCaptureFormats>>&
         descriptors_and_formats) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
@@ -612,7 +612,7 @@ void MediaInternals::UpdateVideoCaptureDeviceCapabilities(
     // parsed by the javascript handler, is brittle. Consider passing
     // a list of mappings instead.
 
-    const media::VideoCaptureDeviceDescriptor& descriptor =
+    const device::VideoCaptureDeviceDescriptor& descriptor =
         std::get<0>(device_format_pair);
     const media::VideoCaptureFormats& supported_formats =
         std::get<1>(device_format_pair);
diff --git a/content/browser/media/media_internals.h b/content/browser/media/media_internals.h
index 77f4fb1..15ce219 100644
--- a/content/browser/media/media_internals.h
+++ b/content/browser/media/media_internals.h
@@ -21,10 +21,10 @@
 #include "content/common/content_export.h"
 #include "content/public/browser/notification_observer.h"
 #include "content/public/browser/notification_registrar.h"
+#include "device/capture/video/video_capture_device_descriptor.h"
 #include "media/audio/audio_logging.h"
 #include "media/base/media_log.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device_descriptor.h"
 
 namespace media {
 class AudioParameters;
@@ -75,7 +75,7 @@ class CONTENT_EXPORT MediaInternals
 
   // Called to inform of the capabilities enumerated for video devices.
   void UpdateVideoCaptureDeviceCapabilities(
-      const std::vector<std::tuple<media::VideoCaptureDeviceDescriptor,
+      const std::vector<std::tuple<device::VideoCaptureDeviceDescriptor,
                                    media::VideoCaptureFormats>>&
           descriptors_and_formats);
 
diff --git a/content/browser/media/media_internals_unittest.cc b/content/browser/media/media_internals_unittest.cc
index f5edac5..ec601c4 100644
--- a/content/browser/media/media_internals_unittest.cc
+++ b/content/browser/media/media_internals_unittest.cc
@@ -112,14 +112,13 @@ class MediaInternalsVideoCaptureDeviceTest : public testing::Test,
   MediaInternals::UpdateCallback update_cb_;
 };
 
-// TODO(chfremer): Consider removing this. This test seem be
-// a duplicate implementation of the functionality under test.
-// https://crbug.com/630694
+// TODO(chfremer): Consider removing this. This test seem to be a duplicate
+// implementation of the functionality under test. https://crbug.com/630694
 #if defined(OS_WIN) || defined(OS_MACOSX) || defined(OS_LINUX) || \
     defined(OS_ANDROID)
 TEST_F(MediaInternalsVideoCaptureDeviceTest,
        AllCaptureApiTypesHaveProperStringRepresentation) {
-  using VideoCaptureApi = media::VideoCaptureApi;
+  using VideoCaptureApi = device::VideoCaptureApi;
   std::map<VideoCaptureApi, std::string> api_to_string_map;
   api_to_string_map[VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE] = "V4L2 SPLANE";
   api_to_string_map[VideoCaptureApi::WIN_MEDIA_FOUNDATION] = "Media Foundation";
@@ -136,7 +135,7 @@ TEST_F(MediaInternalsVideoCaptureDeviceTest,
   EXPECT_EQ(static_cast<size_t>(VideoCaptureApi::UNKNOWN),
             api_to_string_map.size());
   for (const auto& map_entry : api_to_string_map) {
-    media::VideoCaptureDeviceDescriptor descriptor;
+    device::VideoCaptureDeviceDescriptor descriptor;
     descriptor.capture_api = map_entry.first;
     EXPECT_EQ(map_entry.second, descriptor.GetCaptureApiTypeString());
   }
@@ -171,26 +170,25 @@ TEST_F(MediaInternalsVideoCaptureDeviceTest,
   const int kWidth = 1280;
   const int kHeight = 720;
   const float kFrameRate = 30.0f;
-  const media::VideoPixelFormat kPixelFormat =
-      media::PIXEL_FORMAT_I420;
+  const media::VideoPixelFormat kPixelFormat = media::PIXEL_FORMAT_I420;
   const media::VideoCaptureFormat format_hd({kWidth, kHeight},
       kFrameRate, kPixelFormat);
   media::VideoCaptureFormats formats{};
   formats.push_back(format_hd);
-  media::VideoCaptureDeviceDescriptor descriptor;
+  device::VideoCaptureDeviceDescriptor descriptor;
   descriptor.device_id = "dummy";
   descriptor.display_name = "dummy";
 #if defined(OS_MACOSX)
-  descriptor.capture_api = media::VideoCaptureApi::MACOSX_AVFOUNDATION;
+  descriptor.capture_api = device::VideoCaptureApi::MACOSX_AVFOUNDATION;
 #elif defined(OS_WIN)
-  descriptor.capture_api = media::VideoCaptureApi::WIN_DIRECT_SHOW;
+  descriptor.capture_api = device::VideoCaptureApi::WIN_DIRECT_SHOW;
 #elif defined(OS_LINUX)
   descriptor.device_id = "/dev/dummy";
-  descriptor.capture_api = media::VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
+  descriptor.capture_api = device::VideoCaptureApi::LINUX_V4L2_SINGLE_PLANE;
 #elif defined(OS_ANDROID)
-  descriptor.capture_api = media::VideoCaptureApi::ANDROID_API2_LEGACY;
+  descriptor.capture_api = device::VideoCaptureApi::ANDROID_API2_LEGACY;
 #endif
-  std::vector<std::tuple<media::VideoCaptureDeviceDescriptor,
+  std::vector<std::tuple<device::VideoCaptureDeviceDescriptor,
                          media::VideoCaptureFormats>>
       descriptors_and_formats{};
   descriptors_and_formats.push_back(std::make_tuple(descriptor, formats));
diff --git a/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc b/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc
index b030ae9..e9a0060 100644
--- a/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc
+++ b/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc
@@ -32,10 +32,10 @@
 #include "content/public/test/test_browser_thread_bundle.h"
 #include "content/test/test_content_browser_client.h"
 #include "content/test/test_content_client.h"
+#include "device/capture/video/fake_video_capture_device_factory.h"
 #include "ipc/ipc_message_macros.h"
 #include "media/audio/mock_audio_manager.h"
 #include "media/base/media_switches.h"
-#include "media/capture/video/fake_video_capture_device_factory.h"
 #include "net/url_request/url_request_context.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
@@ -260,7 +260,7 @@ class MediaStreamDispatcherHostTest : public testing::Test {
     // Create our own MediaStreamManager.
     media_stream_manager_.reset(new MediaStreamManager(audio_manager_.get()));
     video_capture_device_factory_ =
-        static_cast<media::FakeVideoCaptureDeviceFactory*>(
+        static_cast<device::FakeVideoCaptureDeviceFactory*>(
             media_stream_manager_->video_capture_manager()
             ->video_capture_device_factory());
     DCHECK(video_capture_device_factory_);
@@ -398,7 +398,7 @@ class MediaStreamDispatcherHostTest : public testing::Test {
         if (audio_it->unique_id == devices[i].device.id)
           return true;
       }
-      media::VideoCaptureDeviceDescriptors::const_iterator video_it =
+      device::VideoCaptureDeviceDescriptors::const_iterator video_it =
           physical_video_devices_.begin();
       for (; video_it != physical_video_devices_.end(); ++video_it) {
         if (video_it->device_id == devices[i].device.id)
@@ -424,7 +424,7 @@ class MediaStreamDispatcherHostTest : public testing::Test {
           found_match = true;
         }
       }
-      media::VideoCaptureDeviceDescriptors::const_iterator video_it =
+      device::VideoCaptureDeviceDescriptors::const_iterator video_it =
           physical_video_devices_.begin();
       for (; video_it != physical_video_devices_.end(); ++video_it) {
         if (content::DoesMediaDeviceIDMatchHMAC(
@@ -468,9 +468,9 @@ class MediaStreamDispatcherHostTest : public testing::Test {
   std::unique_ptr<ContentClient> content_client_;
   content::TestBrowserContext browser_context_;
   media::AudioDeviceNames physical_audio_devices_;
-  media::VideoCaptureDeviceDescriptors physical_video_devices_;
+  device::VideoCaptureDeviceDescriptors physical_video_devices_;
   url::Origin origin_;
-  media::FakeVideoCaptureDeviceFactory* video_capture_device_factory_;
+  device::FakeVideoCaptureDeviceFactory* video_capture_device_factory_;
 };
 
 TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithVideoOnly) {
@@ -653,7 +653,7 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsWithMandatorySourceId) {
     EXPECT_EQ(host_->audio_devices_[0].device.id, source_id);
   }
 
-  media::VideoCaptureDeviceDescriptors::const_iterator video_it =
+  device::VideoCaptureDeviceDescriptors::const_iterator video_it =
       physical_video_devices_.begin();
   for (; video_it != physical_video_devices_.end(); ++video_it) {
     std::string source_id = content::GetHMACForMediaDeviceID(
@@ -691,7 +691,7 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsWithOptionalSourceId) {
     EXPECT_EQ(host_->audio_devices_[0].device.id, source_id);
   }
 
-  media::VideoCaptureDeviceDescriptors::const_iterator video_it =
+  device::VideoCaptureDeviceDescriptors::const_iterator video_it =
       physical_video_devices_.begin();
   for (; video_it != physical_video_devices_.end(); ++video_it) {
     std::string source_id = content::GetHMACForMediaDeviceID(
diff --git a/content/browser/renderer_host/media/media_stream_manager.cc b/content/browser/renderer_host/media/media_stream_manager.cc
index 2433951..1caab7e 100644
--- a/content/browser/renderer_host/media/media_stream_manager.cc
+++ b/content/browser/renderer_host/media/media_stream_manager.cc
@@ -49,12 +49,12 @@
 #include "content/public/common/content_switches.h"
 #include "content/public/common/media_stream_request.h"
 #include "crypto/hmac.h"
+#include "device/capture/video/video_capture_device_factory.h"
 #include "media/audio/audio_device_description.h"
 #include "media/audio/audio_manager.h"
 #include "media/base/audio_parameters.h"
 #include "media/base/channel_layout.h"
 #include "media/base/media_switches.h"
-#include "media/capture/video/video_capture_device_factory.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 
@@ -67,7 +67,7 @@
 #endif
 
 #if defined(OS_MACOSX)
-#include "media/capture/device_monitor_mac.h"
+#include "device/capture/device_monitor_mac.h"
 #endif
 
 namespace content {
@@ -1598,7 +1598,7 @@ void MediaStreamManager::InitializeDeviceManagersOnIOThread() {
       FROM_HERE_WITH_EXPLICIT_FUNCTION(
           "457525 MediaStreamManager::InitializeDeviceManagersOnIOThread 4"));
   video_capture_manager_ =
-      new VideoCaptureManager(media::VideoCaptureDeviceFactory::CreateFactory(
+      new VideoCaptureManager(device::VideoCaptureDeviceFactory::CreateFactory(
           BrowserThread::GetTaskRunnerForThread(BrowserThread::UI)));
 #if defined(OS_WIN)
   // Use an STA Video Capture Thread to try to avoid crashes on enumeration of
diff --git a/content/browser/renderer_host/media/media_stream_ui_proxy.cc b/content/browser/renderer_host/media/media_stream_ui_proxy.cc
index 9997a76..bf19cb7 100644
--- a/content/browser/renderer_host/media/media_stream_ui_proxy.cc
+++ b/content/browser/renderer_host/media/media_stream_ui_proxy.cc
@@ -13,7 +13,7 @@
 #include "content/browser/frame_host/render_frame_host_impl.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/common/content_switches.h"
-#include "media/capture/video/fake_video_capture_device.h"
+#include "device/capture/video/fake_video_capture_device.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 
diff --git a/content/browser/renderer_host/media/video_capture_controller.cc b/content/browser/renderer_host/media/video_capture_controller.cc
index 1094773..002f893 100644
--- a/content/browser/renderer_host/media/video_capture_controller.cc
+++ b/content/browser/renderer_host/media/video_capture_controller.cc
@@ -144,7 +144,7 @@ VideoCaptureController::GetWeakPtrForIOThread() {
   return weak_ptr_factory_.GetWeakPtr();
 }
 
-std::unique_ptr<media::VideoCaptureDevice::Client>
+std::unique_ptr<device::VideoCaptureDevice::Client>
 VideoCaptureController::NewDeviceClient() {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   return base::WrapUnique(new VideoCaptureDeviceClient(
@@ -355,7 +355,7 @@ VideoCaptureController::~VideoCaptureController() {
 }
 
 void VideoCaptureController::DoIncomingCapturedVideoFrameOnIOThread(
-    std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer,
+    std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer,
     const scoped_refptr<VideoFrame>& frame) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   const int buffer_id = buffer->id();
@@ -458,7 +458,7 @@ void VideoCaptureController::DoBufferDestroyedOnIOThread(
 
 void VideoCaptureController::DoNewBufferOnIOThread(
     ControllerClient* client,
-    media::VideoCaptureDevice::Client::Buffer* buffer,
+    device::VideoCaptureDevice::Client::Buffer* buffer,
     const scoped_refptr<media::VideoFrame>& frame) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   const int buffer_id = buffer->id();
diff --git a/content/browser/renderer_host/media/video_capture_controller.h b/content/browser/renderer_host/media/video_capture_controller.h
index a9b9320..710312d 100644
--- a/content/browser/renderer_host/media/video_capture_controller.h
+++ b/content/browser/renderer_host/media/video_capture_controller.h
@@ -51,8 +51,8 @@
 #include "content/browser/renderer_host/media/video_capture_controller_event_handler.h"
 #include "content/common/content_export.h"
 #include "content/common/media/video_capture.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
 
 namespace content {
 class VideoCaptureBufferPool;
@@ -71,7 +71,7 @@ class CONTENT_EXPORT VideoCaptureController {
 
   // Return a new VideoCaptureDeviceClient to forward capture events to this
   // instance.
-  std::unique_ptr<media::VideoCaptureDevice::Client> NewDeviceClient();
+  std::unique_ptr<device::VideoCaptureDevice::Client> NewDeviceClient();
 
   // Start video capturing and try to use the resolution specified in |params|.
   // Buffers will be shared to the client as necessary. The client will continue
@@ -127,7 +127,7 @@ class CONTENT_EXPORT VideoCaptureController {
 
   // Worker functions on IO thread. Called by the VideoCaptureDeviceClient.
   virtual void DoIncomingCapturedVideoFrameOnIOThread(
-      std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer,
+      std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer,
       const scoped_refptr<media::VideoFrame>& frame);
   virtual void DoErrorOnIOThread();
   virtual void DoLogOnIOThread(const std::string& message);
@@ -139,7 +139,7 @@ class CONTENT_EXPORT VideoCaptureController {
 
   // Notify renderer that a new buffer has been created.
   void DoNewBufferOnIOThread(ControllerClient* client,
-                             media::VideoCaptureDevice::Client::Buffer* buffer,
+                             device::VideoCaptureDevice::Client::Buffer* buffer,
                              const scoped_refptr<media::VideoFrame>& frame);
 
   // Find a client of |id| and |handler| in |clients|.
diff --git a/content/browser/renderer_host/media/video_capture_controller_unittest.cc b/content/browser/renderer_host/media/video_capture_controller_unittest.cc
index 3f19667..b500871 100644
--- a/content/browser/renderer_host/media/video_capture_controller_unittest.cc
+++ b/content/browser/renderer_host/media/video_capture_controller_unittest.cc
@@ -139,7 +139,7 @@ class VideoCaptureControllerTest : public testing::Test {
   std::unique_ptr<MockVideoCaptureControllerEventHandler> client_a_;
   std::unique_ptr<MockVideoCaptureControllerEventHandler> client_b_;
   std::unique_ptr<VideoCaptureController> controller_;
-  std::unique_ptr<media::VideoCaptureDevice::Client> device_;
+  std::unique_ptr<device::VideoCaptureDevice::Client> device_;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureControllerTest);
@@ -293,7 +293,7 @@ TEST_F(VideoCaptureControllerTest, NormalCaptureMultipleClients) {
   // side effect this will cause the first buffer to be shared with clients.
   uint8_t buffer_no = 1;
   ASSERT_EQ(0.0, device_->GetBufferPoolUtilization());
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer(
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer(
       device_->ReserveOutputBuffer(capture_resolution, media::PIXEL_FORMAT_I420,
                                    media::PIXEL_STORAGE_CPU));
   ASSERT_TRUE(buffer.get());
@@ -346,7 +346,7 @@ TEST_F(VideoCaptureControllerTest, NormalCaptureMultipleClients) {
   // Second buffer which ought to use the same shared memory buffer. In this
   // case pretend that the Buffer pointer is held by the device for a long
   // delay. This shouldn't affect anything.
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer2 =
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer2 =
       device_->ReserveOutputBuffer(capture_resolution, media::PIXEL_FORMAT_I420,
                                    media::PIXEL_STORAGE_CPU);
   ASSERT_TRUE(buffer2.get());
@@ -405,7 +405,7 @@ TEST_F(VideoCaptureControllerTest, NormalCaptureMultipleClients) {
 
   // Third, fourth, and fifth buffers. Pretend they all arrive at the same time.
   for (int i = 0; i < kPoolSize; i++) {
-    std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer =
+    std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer =
         device_->ReserveOutputBuffer(capture_resolution,
                                      media::PIXEL_FORMAT_I420,
                                      media::PIXEL_STORAGE_CPU);
@@ -456,7 +456,7 @@ TEST_F(VideoCaptureControllerTest, NormalCaptureMultipleClients) {
   EXPECT_CALL(*client_b_, DoEnded(client_b_route_1)).Times(1);
   controller_->StopSession(300);
   // Queue up another buffer.
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer3 =
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer3 =
       device_->ReserveOutputBuffer(capture_resolution, media::PIXEL_FORMAT_I420,
                                    media::PIXEL_STORAGE_CPU);
   ASSERT_TRUE(buffer3.get());
@@ -468,7 +468,7 @@ TEST_F(VideoCaptureControllerTest, NormalCaptureMultipleClients) {
       media::VideoFrameMetadata::REFERENCE_TIME, base::TimeTicks());
   device_->OnIncomingCapturedVideoFrame(std::move(buffer3), video_frame);
 
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer4 =
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer4 =
       device_->ReserveOutputBuffer(capture_resolution, media::PIXEL_FORMAT_I420,
                                    media::PIXEL_STORAGE_CPU);
   {
@@ -524,7 +524,7 @@ TEST_F(VideoCaptureControllerTest, ErrorBeforeDeviceCreation) {
   base::RunLoop().RunUntilIdle();
   Mock::VerifyAndClearExpectations(client_b_.get());
 
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer(
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer(
       device_->ReserveOutputBuffer(capture_resolution, media::PIXEL_FORMAT_I420,
                                    media::PIXEL_STORAGE_CPU));
   ASSERT_TRUE(buffer.get());
@@ -562,7 +562,7 @@ TEST_F(VideoCaptureControllerTest, ErrorAfterDeviceCreation) {
   Mock::VerifyAndClearExpectations(client_a_.get());
 
   const gfx::Size dims(320, 240);
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer(
+  std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer(
       device_->ReserveOutputBuffer(dims, media::PIXEL_FORMAT_I420,
                                    media::PIXEL_STORAGE_CPU));
   ASSERT_TRUE(buffer.get());
diff --git a/content/browser/renderer_host/media/video_capture_device_client.cc b/content/browser/renderer_host/media/video_capture_device_client.cc
index cd39c5f..fd5d5d6 100644
--- a/content/browser/renderer_host/media/video_capture_device_client.cc
+++ b/content/browser/renderer_host/media/video_capture_device_client.cc
@@ -32,7 +32,7 @@ namespace content {
 
 // Class combining a Client::Buffer interface implementation and a pool buffer
 // implementation to guarantee proper cleanup on destruction on our side.
-class AutoReleaseBuffer : public media::VideoCaptureDevice::Client::Buffer {
+class AutoReleaseBuffer : public device::VideoCaptureDevice::Client::Buffer {
  public:
   AutoReleaseBuffer(const scoped_refptr<VideoCaptureBufferPool>& pool,
                     int buffer_id)
@@ -264,7 +264,7 @@ void VideoCaptureDeviceClient::OnIncomingCapturedData(
                            timestamp);
 }
 
-std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>
+std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>
 VideoCaptureDeviceClient::ReserveOutputBuffer(
     const gfx::Size& frame_size,
     media::VideoPixelFormat pixel_format,
@@ -342,7 +342,7 @@ void VideoCaptureDeviceClient::OnIncomingCapturedVideoFrame(
           controller_, base::Passed(&buffer), frame));
 }
 
-std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>
+std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>
 VideoCaptureDeviceClient::ResurrectLastOutputBuffer(
     const gfx::Size& dimensions,
     media::VideoPixelFormat format,
@@ -382,7 +382,7 @@ double VideoCaptureDeviceClient::GetBufferPoolUtilization() const {
   return buffer_pool_->GetBufferPoolUtilization();
 }
 
-std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>
+std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>
 VideoCaptureDeviceClient::ReserveI420OutputBuffer(
     const gfx::Size& dimensions,
     media::VideoPixelStorage storage,
diff --git a/content/browser/renderer_host/media/video_capture_device_client.h b/content/browser/renderer_host/media/video_capture_device_client.h
index c5447ca..ed64481 100644
--- a/content/browser/renderer_host/media/video_capture_device_client.h
+++ b/content/browser/renderer_host/media/video_capture_device_client.h
@@ -14,7 +14,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
 #include "content/common/content_export.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
 namespace content {
 class VideoCaptureBufferPool;
@@ -36,7 +36,7 @@ class VideoCaptureGpuJpegDecoder;
 // manages the necessary entities to interact with the GPU process, notably an
 // offscreen Context to avoid janking the UI thread.
 class CONTENT_EXPORT VideoCaptureDeviceClient
-    : public media::VideoCaptureDevice::Client,
+    : public device::VideoCaptureDevice::Client,
       public base::SupportsWeakPtr<VideoCaptureDeviceClient> {
  public:
   VideoCaptureDeviceClient(
diff --git a/content/browser/renderer_host/media/video_capture_device_client_unittest.cc b/content/browser/renderer_host/media/video_capture_device_client_unittest.cc
index c944647..0a06d42 100644
--- a/content/browser/renderer_host/media/video_capture_device_client_unittest.cc
+++ b/content/browser/renderer_host/media/video_capture_device_client_unittest.cc
@@ -44,7 +44,7 @@ class MockVideoCaptureController : public VideoCaptureController {
   MOCK_METHOD1(DoBufferDestroyedOnIOThread, void(int buffer_id_to_drop));
 
   void DoIncomingCapturedVideoFrameOnIOThread(
-      std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> buffer,
+      std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> buffer,
       const scoped_refptr<media::VideoFrame>& frame) override {
     MockDoIncomingCapturedVideoFrameOnIOThread(frame->coded_size());
   }
@@ -63,7 +63,7 @@ class VideoCaptureDeviceClientTest : public ::testing::Test {
  protected:
   const content::TestBrowserThreadBundle thread_bundle_;
   const std::unique_ptr<MockVideoCaptureController> controller_;
-  const std::unique_ptr<media::VideoCaptureDevice::Client> device_client_;
+  const std::unique_ptr<device::VideoCaptureDevice::Client> device_client_;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceClientTest);
diff --git a/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc b/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc
index fece159..5ccf2a7 100644
--- a/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc
+++ b/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.cc
@@ -81,7 +81,7 @@ void VideoCaptureGpuJpegDecoder::DecodeCapturedData(
     const media::VideoCaptureFormat& frame_format,
     base::TimeTicks reference_time,
     base::TimeDelta timestamp,
-    std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> out_buffer) {
+    std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> out_buffer) {
   DCHECK(CalledOnValidThread());
   DCHECK(decoder_);
 
diff --git a/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.h b/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.h
index 85f94f0..17ad900 100644
--- a/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.h
+++ b/content/browser/renderer_host/media/video_capture_gpu_jpeg_decoder.h
@@ -18,7 +18,7 @@
 #include "base/single_thread_task_runner.h"
 #include "base/threading/thread.h"
 #include "content/common/content_export.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/video/jpeg_decode_accelerator.h"
 
 namespace gpu {
@@ -53,7 +53,7 @@ class CONTENT_EXPORT VideoCaptureGpuJpegDecoder
   };
 
   typedef base::Callback<void(
-      std::unique_ptr<media::VideoCaptureDevice::Client::Buffer>,
+      std::unique_ptr<device::VideoCaptureDevice::Client::Buffer>,
       const scoped_refptr<media::VideoFrame>&)>
       DecodeDoneCB;
 
@@ -76,7 +76,7 @@ class CONTENT_EXPORT VideoCaptureGpuJpegDecoder
       const media::VideoCaptureFormat& frame_format,
       base::TimeTicks reference_time,
       base::TimeDelta timestamp,
-      std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> out_buffer);
+      std::unique_ptr<device::VideoCaptureDevice::Client::Buffer> out_buffer);
 
   // JpegDecodeAccelerator::Client implementation.
   // These will be called on IO thread.
diff --git a/content/browser/renderer_host/media/video_capture_manager.cc b/content/browser/renderer_host/media/video_capture_manager.cc
index 96fc5a1..4e5b0258 100644
--- a/content/browser/renderer_host/media/video_capture_manager.cc
+++ b/content/browser/renderer_host/media/video_capture_manager.cc
@@ -29,10 +29,10 @@
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/desktop_media_id.h"
 #include "content/public/common/media_stream_request.h"
+#include "device/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device_factory.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/base/media_switches.h"
-#include "media/capture/video/video_capture_device.h"
-#include "media/capture/video/video_capture_device_factory.h"
 
 #if defined(ENABLE_SCREEN_CAPTURE)
 #include "content/browser/media/capture/desktop_capture_device.h"
@@ -142,7 +142,7 @@ class VideoCaptureManager::DeviceEntry {
   const media::VideoCaptureParams parameters;
 
   VideoCaptureController* video_capture_controller() const;
-  media::VideoCaptureDevice* video_capture_device() const;
+  device::VideoCaptureDevice* video_capture_device() const;
 
   void SetVideoCaptureDevice(std::unique_ptr<VideoCaptureDevice> device);
   std::unique_ptr<VideoCaptureDevice> ReleaseVideoCaptureDevice();
@@ -155,16 +155,16 @@ class VideoCaptureManager::DeviceEntry {
   base::ThreadChecker thread_checker_;
 };
 
-// Bundles a media::VideoCaptureDeviceDescriptor with corresponding supported
+// Bundles a device::VideoCaptureDeviceDescriptor with corresponding supported
 // video formats.
 struct VideoCaptureManager::DeviceInfo {
   DeviceInfo();
-  DeviceInfo(media::VideoCaptureDeviceDescriptor descriptor);
+  DeviceInfo(device::VideoCaptureDeviceDescriptor descriptor);
   DeviceInfo(const DeviceInfo& other);
   ~DeviceInfo();
   DeviceInfo& operator=(const DeviceInfo& other);
 
-  media::VideoCaptureDeviceDescriptor descriptor;
+  device::VideoCaptureDeviceDescriptor descriptor;
   media::VideoCaptureFormats supported_formats;
 };
 
@@ -206,7 +206,7 @@ VideoCaptureManager::DeviceEntry::DeviceEntry(
 VideoCaptureManager::DeviceEntry::~DeviceEntry() {
   DCHECK(thread_checker_.CalledOnValidThread());
   // DCHECK that this DeviceEntry does not still own a
-  // media::VideoCaptureDevice. media::VideoCaptureDevice must be deleted on
+  // device::VideoCaptureDevice. media::VideoCaptureDevice must be deleted on
   // the device thread.
   DCHECK(video_capture_device_ == nullptr);
 }
@@ -217,7 +217,7 @@ void VideoCaptureManager::DeviceEntry::SetVideoCaptureDevice(
   video_capture_device_.swap(device);
 }
 
-std::unique_ptr<media::VideoCaptureDevice>
+std::unique_ptr<device::VideoCaptureDevice>
 VideoCaptureManager::DeviceEntry::ReleaseVideoCaptureDevice() {
   DCHECK(thread_checker_.CalledOnValidThread());
   return std::move(video_capture_device_);
@@ -229,7 +229,7 @@ VideoCaptureManager::DeviceEntry::video_capture_controller() const {
   return video_capture_controller_.get();
 }
 
-media::VideoCaptureDevice*
+device::VideoCaptureDevice*
 VideoCaptureManager::DeviceEntry::video_capture_device() const {
   DCHECK(thread_checker_.CalledOnValidThread());
   return video_capture_device_.get();
@@ -238,7 +238,7 @@ VideoCaptureManager::DeviceEntry::video_capture_device() const {
 VideoCaptureManager::DeviceInfo::DeviceInfo() = default;
 
 VideoCaptureManager::DeviceInfo::DeviceInfo(
-    media::VideoCaptureDeviceDescriptor descriptor)
+    device::VideoCaptureDeviceDescriptor descriptor)
     : descriptor(descriptor) {}
 
 VideoCaptureManager::DeviceInfo::DeviceInfo(
@@ -260,7 +260,7 @@ VideoCaptureManager::CaptureDeviceStartRequest::CaptureDeviceStartRequest(
 }
 
 VideoCaptureManager::VideoCaptureManager(
-    std::unique_ptr<media::VideoCaptureDeviceFactory> factory)
+    std::unique_ptr<device::VideoCaptureDeviceFactory> factory)
     : listener_(nullptr),
       new_capture_session_id_(1),
       video_capture_device_factory_(std::move(factory)) {}
@@ -319,7 +319,7 @@ void VideoCaptureManager::EnumerateDevices(MediaStreamType stream_type) {
   // bound in |devices_enumerated_callback|.
   device_task_runner_->PostTask(
       FROM_HERE,
-      base::Bind(&media::VideoCaptureDeviceFactory::EnumerateDeviceDescriptors,
+      base::Bind(&device::VideoCaptureDeviceFactory::EnumerateDeviceDescriptors,
                  base::Unretained(video_capture_device_factory_.get()),
                  devices_enumerated_callback));
 }
@@ -525,7 +525,7 @@ void VideoCaptureManager::OnDeviceStarted(
     // DoStartDeviceCaptureOnDeviceThread.
     // The device is no longer wanted. Stop the device again.
     DVLOG(3) << "OnDeviceStarted but start request have been aborted.";
-    media::VideoCaptureDevice* device_ptr = device.get();
+    device::VideoCaptureDevice* device_ptr = device.get();
     base::Closure closure =
         base::Bind(&VideoCaptureManager::DoStopDeviceOnDeviceThread, this,
                    base::Passed(&device));
@@ -551,7 +551,7 @@ void VideoCaptureManager::OnDeviceStarted(
   HandleQueuedStartRequest();
 }
 
-std::unique_ptr<media::VideoCaptureDevice>
+std::unique_ptr<device::VideoCaptureDevice>
 VideoCaptureManager::DoStartDeviceCaptureOnDeviceThread(
     const VideoCaptureDeviceDescriptor& descriptor,
     const media::VideoCaptureParams& params,
@@ -572,7 +572,7 @@ VideoCaptureManager::DoStartDeviceCaptureOnDeviceThread(
   return video_capture_device;
 }
 
-std::unique_ptr<media::VideoCaptureDevice>
+std::unique_ptr<device::VideoCaptureDevice>
 VideoCaptureManager::DoStartTabCaptureOnDeviceThread(
     const std::string& id,
     const media::VideoCaptureParams& params,
@@ -592,7 +592,7 @@ VideoCaptureManager::DoStartTabCaptureOnDeviceThread(
   return video_capture_device;
 }
 
-std::unique_ptr<media::VideoCaptureDevice>
+std::unique_ptr<device::VideoCaptureDevice>
 VideoCaptureManager::DoStartDesktopCaptureOnDeviceThread(
     const std::string& id,
     const media::VideoCaptureParams& params,
@@ -754,7 +754,7 @@ void VideoCaptureManager::RequestRefreshFrameForClient(
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   if (DeviceEntry* entry = GetDeviceEntryByController(controller)) {
-    if (media::VideoCaptureDevice* device = entry->video_capture_device()) {
+    if (device::VideoCaptureDevice* device = entry->video_capture_device()) {
       device_task_runner_->PostTask(
           FROM_HERE,
           base::Bind(&VideoCaptureDevice::RequestRefreshFrame,
@@ -950,7 +950,7 @@ void VideoCaptureManager::OnDevicesInfoEnumerated(
   // Walk the |devices_info_cache_| and transform from
   // VideoCaptureDeviceDescriptor to StreamDeviceInfo for return purposes.
   StreamDeviceInfoArray devices;
-  std::vector<std::tuple<media::VideoCaptureDeviceDescriptor,
+  std::vector<std::tuple<device::VideoCaptureDeviceDescriptor,
                          media::VideoCaptureFormats>>
       descriptors_and_formats;
   for (const auto& it : devices_info_cache_) {
@@ -1025,7 +1025,7 @@ void VideoCaptureManager::DestroyDeviceEntryIfNoClients(DeviceEntry* entry) {
   }
 }
 
-media::VideoCaptureDevice*
+device::VideoCaptureDevice*
 VideoCaptureManager::GetVideoCaptureDeviceBySessionId(int session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   SessionMap::const_iterator session_it = sessions_.find(session_id);
@@ -1114,7 +1114,7 @@ VideoCaptureManager::DeviceEntry* VideoCaptureManager::GetOrCreateDeviceEntry(
 }
 
 void VideoCaptureManager::SetDesktopCaptureWindowIdOnDeviceThread(
-    media::VideoCaptureDevice* device,
+    device::VideoCaptureDevice* device,
     gfx::NativeViewId window_id) {
   DCHECK(IsOnDeviceThread());
 #if defined(ENABLE_SCREEN_CAPTURE)
diff --git a/content/browser/renderer_host/media/video_capture_manager.h b/content/browser/renderer_host/media/video_capture_manager.h
index 20be47f..8fb5e86 100644
--- a/content/browser/renderer_host/media/video_capture_manager.h
+++ b/content/browser/renderer_host/media/video_capture_manager.h
@@ -29,9 +29,9 @@
 #include "content/browser/renderer_host/media/video_capture_controller_event_handler.h"
 #include "content/common/content_export.h"
 #include "content/common/media/media_stream_options.h"
+#include "device/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device_factory.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
-#include "media/capture/video/video_capture_device_factory.h"
 
 #if defined(OS_ANDROID)
 #include "base/android/application_status_listener.h"
@@ -44,14 +44,14 @@ class VideoCaptureControllerEventHandler;
 // VideoCaptureManager opens/closes and start/stops video capture devices.
 class CONTENT_EXPORT VideoCaptureManager : public MediaStreamProvider {
  public:
-  using VideoCaptureDevice = media::VideoCaptureDevice;
+  using VideoCaptureDevice = device::VideoCaptureDevice;
 
   // Callback used to signal the completion of a controller lookup.
   using DoneCB =
       base::Callback<void(const base::WeakPtr<VideoCaptureController>&)>;
 
   explicit VideoCaptureManager(
-      std::unique_ptr<media::VideoCaptureDeviceFactory> factory);
+      std::unique_ptr<device::VideoCaptureDeviceFactory> factory);
 
   void Unregister();
 
@@ -140,7 +140,7 @@ class CONTENT_EXPORT VideoCaptureManager : public MediaStreamProvider {
                                  gfx::NativeViewId window_id);
 
   // Gets a weak reference to the device factory, used for tests.
-  media::VideoCaptureDeviceFactory* video_capture_device_factory() const {
+  device::VideoCaptureDeviceFactory* video_capture_device_factory() const {
     return video_capture_device_factory_.get();
   }
 
@@ -181,8 +181,8 @@ class CONTENT_EXPORT VideoCaptureManager : public MediaStreamProvider {
   using DeviceEntries = std::vector<std::unique_ptr<DeviceEntry>>;
   using DeviceInfos = std::vector<DeviceInfo>;
   using DeviceStartQueue = std::list<CaptureDeviceStartRequest>;
-  using VideoCaptureDeviceDescriptor = media::VideoCaptureDeviceDescriptor;
-  using VideoCaptureDeviceDescriptors = media::VideoCaptureDeviceDescriptors;
+  using VideoCaptureDeviceDescriptor = device::VideoCaptureDeviceDescriptor;
+  using VideoCaptureDeviceDescriptors = device::VideoCaptureDeviceDescriptors;
 
   ~VideoCaptureManager() override;
 
@@ -271,9 +271,8 @@ class CONTENT_EXPORT VideoCaptureManager : public MediaStreamProvider {
   void DoStopDeviceOnDeviceThread(std::unique_ptr<VideoCaptureDevice> device);
 
   void MaybePostDesktopCaptureWindowId(media::VideoCaptureSessionId session_id);
-  void SetDesktopCaptureWindowIdOnDeviceThread(
-      media::VideoCaptureDevice* device,
-      gfx::NativeViewId window_id);
+  void SetDesktopCaptureWindowIdOnDeviceThread(VideoCaptureDevice* device,
+                                               gfx::NativeViewId window_id);
 
 #if defined(OS_MACOSX)
   // Called on the IO thread after the device layer has been initialized on Mac.
@@ -326,7 +325,7 @@ class CONTENT_EXPORT VideoCaptureManager : public MediaStreamProvider {
 
   // Device creation factory injected on construction from MediaStreamManager or
   // from the test harness.
-  std::unique_ptr<media::VideoCaptureDeviceFactory>
+  std::unique_ptr<device::VideoCaptureDeviceFactory>
       video_capture_device_factory_;
 
   // Local cache of the enumerated video capture devices' names and capture
diff --git a/content/browser/renderer_host/media/video_capture_manager_unittest.cc b/content/browser/renderer_host/media/video_capture_manager_unittest.cc
index c2cc9c7..bbda17a 100644
--- a/content/browser/renderer_host/media/video_capture_manager_unittest.cc
+++ b/content/browser/renderer_host/media/video_capture_manager_unittest.cc
@@ -19,7 +19,7 @@
 #include "content/browser/renderer_host/media/media_stream_provider.h"
 #include "content/browser/renderer_host/media/video_capture_controller_event_handler.h"
 #include "content/common/media/media_stream_options.h"
-#include "media/capture/video/fake_video_capture_device_factory.h"
+#include "device/capture/video/fake_video_capture_device_factory.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -82,10 +82,10 @@ class VideoCaptureManagerTest : public testing::Test {
     io_thread_.reset(new BrowserThreadImpl(BrowserThread::IO,
                                            message_loop_.get()));
     vcm_ = new VideoCaptureManager(
-        std::unique_ptr<media::VideoCaptureDeviceFactory>(
-            new media::FakeVideoCaptureDeviceFactory()));
+        std::unique_ptr<device::VideoCaptureDeviceFactory>(
+            new device::FakeVideoCaptureDeviceFactory()));
     video_capture_device_factory_ =
-        static_cast<media::FakeVideoCaptureDeviceFactory*>(
+        static_cast<device::FakeVideoCaptureDeviceFactory*>(
             vcm_->video_capture_device_factory());
     const int32_t kNumberOfFakeDevices = 2;
     video_capture_device_factory_->set_number_of_devices(kNumberOfFakeDevices);
@@ -173,7 +173,7 @@ class VideoCaptureManagerTest : public testing::Test {
   std::unique_ptr<BrowserThreadImpl> ui_thread_;
   std::unique_ptr<BrowserThreadImpl> io_thread_;
   std::unique_ptr<MockFrameObserver> frame_observer_;
-  media::FakeVideoCaptureDeviceFactory* video_capture_device_factory_;
+  device::FakeVideoCaptureDeviceFactory* video_capture_device_factory_;
 
  private:
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureManagerTest);
diff --git a/content/common/BUILD.gn b/content/common/BUILD.gn
index c5d320a..d94d916 100644
--- a/content/common/BUILD.gn
+++ b/content/common/BUILD.gn
@@ -48,6 +48,7 @@ source_set("common") {
     "//content:resources",
     "//content/app/resources",
     "//device/bluetooth",
+    "//device/capture",
     "//gpu",
     "//gpu/command_buffer/client:gles2_c_lib",
     "//gpu/command_buffer/client:gles2_cmd_helper",
@@ -62,7 +63,6 @@ source_set("common") {
     "//media",
     "//media:shared_memory_support",
     "//media/base/ipc",
-    "//media/capture",
     "//media/gpu/ipc/client",
     "//media/gpu/ipc/common",
     "//media/midi",
diff --git a/content/public/android/BUILD.gn b/content/public/android/BUILD.gn
index 64fd9af..785e309 100644
--- a/content/public/android/BUILD.gn
+++ b/content/public/android/BUILD.gn
@@ -42,8 +42,6 @@ android_library("content_java") {
     "//device/vibration/android:vibration_manager_android",
     "//device/vr:java",
     "//media/base/android:media_java",
-    "//media/capture/content/android:screen_capture_java",
-    "//media/capture/video/android:capture_java",
     "//media/midi:midi_java",
     "//mojo/android:system_java",
     "//mojo/public/java:bindings",
@@ -306,13 +304,12 @@ android_library("content_javatests") {
     "//content/shell/android:content_shell_apk_java",
     "//content/shell/android:content_shell_java",
     "//content/shell/android:content_shell_test_java",
+    "//device/capture:capture_java",
     "//device/geolocation:geolocation_java",
     "//device/geolocation:geolocation_java_test_support",
     "//device/vibration:mojo_bindings_java",
     "//device/vibration/android:vibration_manager_android",
     "//media/base/android:media_java",
-    "//media/capture/content/android:screen_capture_java",
-    "//media/capture/video/android:capture_java",
     "//mojo/android:system_java",
     "//mojo/public/interfaces/bindings/tests:test_interfaces_java",
     "//mojo/public/java:bindings",
diff --git a/content/public/test/content_test_suite_base.cc b/content/public/test/content_test_suite_base.cc
index 69cf50c..9b654ba 100644
--- a/content/public/test/content_test_suite_base.cc
+++ b/content/public/test/content_test_suite_base.cc
@@ -33,9 +33,9 @@
 #include "base/android/jni_android.h"
 #include "content/browser/android/browser_jni_registrar.h"
 #include "content/common/android/common_jni_registrar.h"
+#include "device/capture/video/android/capture_jni_registrar.h"
 #include "device/geolocation/android/geolocation_jni_registrar.h"
 #include "media/base/android/media_jni_registrar.h"
-#include "media/capture/video/android/capture_jni_registrar.h"
 #include "net/android/net_jni_registrar.h"
 #include "ui/android/ui_android_jni_registrar.h"
 #include "ui/base/android/ui_base_jni_registrar.h"
@@ -89,8 +89,8 @@ void ContentTestSuiteBase::Initialize() {
   content::android::RegisterCommonJni(env);
   content::android::RegisterBrowserJni(env);
   device::android::RegisterGeolocationJni(env);
+  device::RegisterCaptureJni(env);
   gfx::android::RegisterJni(env);
-  media::RegisterCaptureJni(env);
   media::RegisterJni(env);
   net::android::RegisterJni(env);
   ui::android::RegisterJni(env);
diff --git a/content/renderer/BUILD.gn b/content/renderer/BUILD.gn
index c1778f7..8dc9178 100644
--- a/content/renderer/BUILD.gn
+++ b/content/renderer/BUILD.gn
@@ -56,6 +56,7 @@ target(link_target_type, "renderer") {
     "//crypto:platform",
     "//device/battery:mojo_bindings",
     "//device/bluetooth",
+    "//device/capture",
     "//device/usb/public/interfaces",
     "//device/vibration:mojo_bindings",
     "//device/vr:mojo_bindings",
@@ -65,7 +66,6 @@ target(link_target_type, "renderer") {
     "//jingle:jingle_glue",
     "//media",
     "//media/blink",
-    "//media/capture",
     "//media/gpu",
     "//media/gpu/ipc/client",
     "//media/gpu/ipc/common",
diff --git a/content/shell/android/BUILD.gn b/content/shell/android/BUILD.gn
index 0c2b83b..42f67fd 100644
--- a/content/shell/android/BUILD.gn
+++ b/content/shell/android/BUILD.gn
@@ -45,9 +45,9 @@ android_library("content_shell_java") {
     ":content_shell_java_resources",
     "//base:base_java",
     "//content/public/android:content_java",
+    "//device/capture:capture_java",
     "//device/geolocation:geolocation_java",
     "//media/base/android:media_java",
-    "//media/capture/video/android:capture_java",
     "//mojo/public/java:system",
     "//net/android:net_java",
     "//ui/android:ui_java",
@@ -87,7 +87,7 @@ android_library("content_shell_apk_java") {
     ":content_shell_manifest",
     "//base:base_java",
     "//content/public/android:content_java",
-    "//media/capture/video/android:capture_java",
+    "//device/capture:capture_java",
     "//net/android:net_java",
     "//ui/android:ui_java",
   ]
@@ -122,7 +122,7 @@ android_apk("content_shell_apk") {
     "//base:base_java",
     "//content/public/android:content_java",
     "//content/public/test/android:layouttest_java_support",
-    "//media/capture/video/android:capture_java",
+    "//device/capture:capture_java",
     "//net/android:net_java",
     "//third_party/mesa:osmesa",
     "//ui/android:ui_java",
diff --git a/content/test/BUILD.gn b/content/test/BUILD.gn
index 54c6403..0774ec66 100644
--- a/content/test/BUILD.gn
+++ b/content/test/BUILD.gn
@@ -78,11 +78,11 @@ static_library("test_support") {
     "//content/renderer:for_content_tests",
     "//content/shell:pak",
     "//content/utility:for_content_tests",
+    "//device/capture",
     "//device/geolocation:device_geolocation",
     "//device/nfc:mojo_bindings",
     "//ipc:test_support",
     "//media",
-    "//media/capture",
     "//media/mojo/interfaces:image_capture",
     "//mojo/edk/system",
     "//mojo/edk/test:test_support",
@@ -193,8 +193,8 @@ static_library("test_support") {
 
   if (is_android) {
     deps += [
+      "//device/capture:capture_java",
       "//device/geolocation:geolocation_java",
-      "//media/capture/video/android:android",
       "//ui/android",
       "//ui/shell_dialogs",
     ]
@@ -654,6 +654,7 @@ test("content_unittests") {
     "//device/battery:mojo_bindings",
     "//device/bluetooth",
     "//device/bluetooth:mocks",
+    "//device/capture",
     "//device/gamepad",
     "//device/gamepad:test_helpers",
     "//gin",
@@ -664,7 +665,6 @@ test("content_unittests") {
     "//media:test_support",
     "//media/audio:test_support",
     "//media/base:test_support",
-    "//media/capture",
     "//media/midi:midi",
     "//mojo/edk/test:test_support",
     "//mojo/public/cpp/bindings",
@@ -808,6 +808,7 @@ test("content_unittests") {
     deps += [
       "//base:base_java_unittest_support",
       "//content/public/android:content_java",
+      "//device/capture:capture_java",
       "//device/geolocation:geolocation_java",
       "//v8:v8_external_startup_data_assets",
     ]
diff --git a/media/capture/BUILD.gn b/device/capture/BUILD.gn
similarity index 69%
rename from media/capture/BUILD.gn
rename to device/capture/BUILD.gn
index 337cd2c..97eecc8 100644
--- a/media/capture/BUILD.gn
+++ b/device/capture/BUILD.gn
@@ -5,11 +5,31 @@
 import("//build/config/features.gni")
 import("//media/media_options.gni")
 import("//testing/test.gni")
+if (is_android) {
+  import("//build/config/android/rules.gni")  # For generate_jni().
+}
 
 component("capture") {
   defines = [ "CAPTURE_IMPLEMENTATION" ]
+
+  public_deps = []
+  deps = [
+    "//base",
+    "//base:i18n",
+    "//media",
+    "//media/mojo/interfaces:image_capture",
+    "//skia",
+    "//third_party/libyuv",
+    "//ui/display",
+    "//ui/gfx",
+  ]
+
   sources = [
     "capture_export.h",
+    "content/android/screen_capture_jni_registrar.cc",
+    "content/android/screen_capture_jni_registrar.h",
+    "content/android/screen_capture_machine_android.cc",
+    "content/android/screen_capture_machine_android.h",
     "content/animated_content_sampler.cc",
     "content/animated_content_sampler.h",
     "content/capture_resolution_chooser.cc",
@@ -26,6 +46,14 @@ component("capture") {
     "device_monitor_mac.mm",
     "system_message_window_win.cc",
     "system_message_window_win.h",
+    "video/android/capture_jni_registrar.cc",
+    "video/android/capture_jni_registrar.h",
+    "video/android/photo_capabilities.cc",
+    "video/android/photo_capabilities.h",
+    "video/android/video_capture_device_android.cc",
+    "video/android/video_capture_device_android.h",
+    "video/android/video_capture_device_factory_android.cc",
+    "video/android/video_capture_device_factory_android.h",
     "video/fake_video_capture_device.cc",
     "video/fake_video_capture_device.h",
     "video/fake_video_capture_device_factory.cc",
@@ -75,17 +103,6 @@ component("capture") {
     "video/win/video_capture_device_win.h",
   ]
 
-  public_deps = []
-  deps = [
-    "//base",
-    "//base:i18n",
-    "//media",
-    "//media/mojo/interfaces:image_capture",
-    "//skia",
-    "//ui/display",
-    "//ui/gfx",
-  ]
-
   configs += [
     # TODO(mcasas): media/base should be a component and not a source_set, but
     # it depends on parts of media/filters, media/ffmpeg etc. Until then, we
@@ -95,14 +112,7 @@ component("capture") {
   ]
 
   if (is_android) {
-    public_deps += [
-      "content/android",
-      "video/android",
-    ]
-    deps += [
-      "content/android:screen_capture_jni_headers",
-      "video/android:capture_jni_headers",
-    ]
+    deps += [ ":capture_jni_headers" ]
   }
 
   if (is_mac) {
@@ -133,6 +143,7 @@ component("capture") {
       "mfplat.lib",
       "mfreadwrite.lib",
       "mfuuid.lib",
+      "strmiids.lib",
     ]
     ldflags = [
       "/DELAYLOAD:mf.dll",
@@ -145,6 +156,48 @@ component("capture") {
   }
 }
 
+if (is_android) {
+  generate_jni("capture_jni_headers") {
+    sources = [
+      "content/android/java/src/org/chromium/device/ScreenCapture.java",
+      "video/android/java/src/org/chromium/device/PhotoCapabilities.java",
+      "video/android/java/src/org/chromium/device/VideoCapture.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureFactory.java",
+    ]
+    jni_package = "device"
+  }
+
+  java_cpp_enum("capture_java_enums_srcjar") {
+    sources = [
+      "video/android/video_capture_device_android.h",
+      "video/video_capture_device_descriptor.h",
+    ]
+  }
+
+  android_library("capture_java") {
+    deps = [
+      ":capture",
+      ":capture_jni_headers",
+      "//base:base_java",
+      "//third_party/android_tools:android_support_annotations_java",
+    ]
+
+    srcjar_deps = [ ":capture_java_enums_srcjar" ]
+
+    java_files = [
+      "content/android/java/src/org/chromium/device/ScreenCapture.java",
+      "video/android/java/src/org/chromium/device/PhotoCapabilities.java",
+      "video/android/java/src/org/chromium/device/VideoCapture.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureAndroid.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureCamera.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureCamera2.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureFactory.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureFormat.java",
+      "video/android/java/src/org/chromium/device/VideoCaptureTango.java",
+    ]
+  }
+}
+
 test("capture_unittests") {
   sources = [
     "content/animated_content_sampler_unittest.cc",
@@ -161,6 +214,7 @@ test("capture_unittests") {
     ":capture",
     "//base/test:run_all_unittests",
     "//base/test:test_support",
+    "//media/base",
     "//media/base:test_support",
     "//media/mojo/interfaces:image_capture",
     "//testing/gmock",
@@ -170,8 +224,8 @@ test("capture_unittests") {
 
   if (is_android) {
     deps += [
-      "//media/capture/video/android",
-      "//media/capture/video/android:capture_java",
+      ":capture_java",
+      ":capture_jni_headers",
     ]
   }
 
diff --git a/device/capture/DEPS b/device/capture/DEPS
new file mode 100644
index 0000000..d950ce5
--- /dev/null
+++ b/device/capture/DEPS
@@ -0,0 +1,9 @@
+include_rules = [
+  "+jni",
+  "+media",
+  "+mojo/public/cpp/bindings",
+  "+third_party/libyuv",
+  "+third_party/skia",
+  "+ui/display",
+  "+ui/gfx",
+]
diff --git a/media/capture/OWNERS b/device/capture/OWNERS
similarity index 56%
rename from media/capture/OWNERS
rename to device/capture/OWNERS
index 000874b..17ee6b9 100644
--- a/media/capture/OWNERS
+++ b/device/capture/OWNERS
@@ -1,6 +1,6 @@
 # These individual OWNERS also OWN the global capture/ folder.
 
 # For content/
-file://media/capture/content/OWNERS
+file://device/capture/content/OWNERS
 # For video/
-file://media/capture/video/OWNERS
+file://device/capture/video/OWNERS
diff --git a/media/capture/capture.gyp b/device/capture/capture.gyp
similarity index 100%
rename from media/capture/capture.gyp
rename to device/capture/capture.gyp
diff --git a/media/capture/capture_export.h b/device/capture/capture_export.h
similarity index 83%
rename from media/capture/capture_export.h
rename to device/capture/capture_export.h
index 93c6511..9b19a05 100644
--- a/media/capture/capture_export.h
+++ b/device/capture/capture_export.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CAPTURE_EXPORT_H_
-#define MEDIA_CAPTURE_CAPTURE_EXPORT_H_
+#ifndef DEVICE_CAPTURE_CAPTURE_EXPORT_H_
+#define DEVICE_CAPTURE_CAPTURE_EXPORT_H_
 
 #if defined(COMPONENT_BUILD)
 #if defined(WIN32)
@@ -26,4 +26,4 @@
 #define CAPTURE_EXPORT
 #endif
 
-#endif  // MEDIA_CAPTURE_CAPTURE_EXPORT_H_
+#endif  // DEVICE_CAPTURE_CAPTURE_EXPORT_H_
diff --git a/media/capture/capture_unittests.isolate b/device/capture/capture_unittests.isolate
similarity index 100%
rename from media/capture/capture_unittests.isolate
rename to device/capture/capture_unittests.isolate
diff --git a/media/capture/capture_unittests_apk.isolate b/device/capture/capture_unittests_apk.isolate
similarity index 100%
rename from media/capture/capture_unittests_apk.isolate
rename to device/capture/capture_unittests_apk.isolate
diff --git a/media/capture/content/OWNERS b/device/capture/content/OWNERS
similarity index 100%
rename from media/capture/content/OWNERS
rename to device/capture/content/OWNERS
diff --git a/media/capture/content/README b/device/capture/content/README
similarity index 100%
rename from media/capture/content/README
rename to device/capture/content/README
diff --git a/media/capture/content/android/java/src/org/chromium/media/ScreenCapture.java b/device/capture/content/android/java/src/org/chromium/device/ScreenCapture.java
similarity index 99%
rename from media/capture/content/android/java/src/org/chromium/media/ScreenCapture.java
rename to device/capture/content/android/java/src/org/chromium/device/ScreenCapture.java
index 6ac2a76..008cdf2 100644
--- a/media/capture/content/android/java/src/org/chromium/media/ScreenCapture.java
+++ b/device/capture/content/android/java/src/org/chromium/device/ScreenCapture.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.annotation.TargetApi;
 import android.app.Activity;
@@ -38,7 +38,7 @@ import java.nio.ByteBuffer;
  * API 21 (L Release). Capture takes place in the current Looper, while pixel
  * download takes place in another thread used by ImageReader.
  **/
-@JNINamespace("media")
+@JNINamespace("device")
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class ScreenCapture extends Fragment {
     private static final String TAG = "ScreenCaptureMachine";
diff --git a/media/capture/content/android/screen_capture_jni_registrar.cc b/device/capture/content/android/screen_capture_jni_registrar.cc
similarity index 76%
rename from media/capture/content/android/screen_capture_jni_registrar.cc
rename to device/capture/content/android/screen_capture_jni_registrar.cc
index 9220777..e4f413d 100644
--- a/media/capture/content/android/screen_capture_jni_registrar.cc
+++ b/device/capture/content/android/screen_capture_jni_registrar.cc
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/android/screen_capture_jni_registrar.h"
+#include "device/capture/content/android/screen_capture_jni_registrar.h"
 
 #include "base/android/jni_android.h"
 #include "base/android/jni_registrar.h"
 #include "base/macros.h"
-#include "media/capture/content/android/screen_capture_machine_android.h"
+#include "device/capture/content/android/screen_capture_machine_android.h"
 
-namespace media {
+namespace device {
 
 static const base::android::RegistrationMethod kCaptureRegisteredMethods[] = {
     {"ScreenCaptureMachine",
@@ -21,4 +21,4 @@ bool RegisterScreenCaptureJni(JNIEnv* env) {
       env, kCaptureRegisteredMethods, arraysize(kCaptureRegisteredMethods));
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/device/capture/content/android/screen_capture_jni_registrar.h b/device/capture/content/android/screen_capture_jni_registrar.h
new file mode 100644
index 0000000..327fb45
--- /dev/null
+++ b/device/capture/content/android/screen_capture_jni_registrar.h
@@ -0,0 +1,19 @@
+// Copyright 2016 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef DEVICE_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_JNI_REGISTRAR_H_
+#define DEVICE_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_JNI_REGISTRAR_H_
+
+#include <jni.h>
+
+#include "device/capture/capture_export.h"
+
+namespace device {
+
+// Register all JNI bindings necessary for screen capture.
+bool CAPTURE_EXPORT RegisterScreenCaptureJni(JNIEnv* env);
+
+}  // namespace device
+
+#endif  // DEVICE_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_JNI_REGISTRAR_H_
diff --git a/media/capture/content/android/screen_capture_machine_android.cc b/device/capture/content/android/screen_capture_machine_android.cc
similarity index 92%
rename from media/capture/content/android/screen_capture_machine_android.cc
rename to device/capture/content/android/screen_capture_machine_android.cc
index 204cb55..1b36f87f 100644
--- a/media/capture/content/android/screen_capture_machine_android.cc
+++ b/device/capture/content/android/screen_capture_machine_android.cc
@@ -2,18 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/android/screen_capture_machine_android.h"
+#include "device/capture/content/android/screen_capture_machine_android.h"
 
 #include "base/android/context_utils.h"
 #include "base/android/jni_android.h"
 #include "base/android/scoped_java_ref.h"
+#include "device/capture/content/video_capture_oracle.h"
 #include "jni/ScreenCapture_jni.h"
-#include "media/capture/content/video_capture_oracle.h"
 #include "third_party/libyuv/include/libyuv.h"
 
 using base::android::AttachCurrentThread;
 
-namespace media {
+namespace device {
 
 // static
 bool ScreenCaptureMachineAndroid::RegisterScreenCaptureMachine(JNIEnv* env) {
@@ -55,15 +55,15 @@ void ScreenCaptureMachineAndroid::OnRGBAFrameAvailable(JNIEnv* env,
     return;
   }
 
-  DCHECK(frame->format() == PIXEL_FORMAT_I420 ||
-         frame->format() == PIXEL_FORMAT_YV12);
+  DCHECK(frame->format() == media::PIXEL_FORMAT_I420 ||
+         frame->format() == media::PIXEL_FORMAT_YV12);
 
   scoped_refptr<VideoFrame> temp_frame = frame;
   if (frame->visible_rect().width() != width ||
       frame->visible_rect().height() != height) {
     temp_frame = VideoFrame::CreateFrame(
-        PIXEL_FORMAT_I420, gfx::Size(width, height), gfx::Rect(width, height),
-        gfx::Size(width, height), base::TimeDelta());
+        media::PIXEL_FORMAT_I420, gfx::Size(width, height),
+        gfx::Rect(width, height), gfx::Size(width, height), base::TimeDelta());
   }
 
   uint8_t* const src =
@@ -130,15 +130,15 @@ void ScreenCaptureMachineAndroid::OnI420FrameAvailable(JNIEnv* env,
     return;
   }
 
-  DCHECK(frame->format() == PIXEL_FORMAT_I420 ||
-         frame->format() == PIXEL_FORMAT_YV12);
+  DCHECK(frame->format() == media::PIXEL_FORMAT_I420 ||
+         frame->format() == media::PIXEL_FORMAT_YV12);
 
   scoped_refptr<VideoFrame> temp_frame = frame;
   if (frame->visible_rect().width() != width ||
       frame->visible_rect().height() != height) {
     temp_frame = VideoFrame::CreateFrame(
-        PIXEL_FORMAT_I420, gfx::Size(width, height), gfx::Rect(width, height),
-        gfx::Size(width, height), base::TimeDelta());
+        media::PIXEL_FORMAT_I420, gfx::Size(width, height),
+        gfx::Rect(width, height), gfx::Size(width, height), base::TimeDelta());
   }
 
   uint8_t* const y_src =
@@ -250,8 +250,8 @@ void ScreenCaptureMachineAndroid::MaybeCaptureForRefresh() {
     return;
   }
 
-  DCHECK(frame->format() == PIXEL_FORMAT_I420 ||
-         frame->format() == PIXEL_FORMAT_YV12);
+  DCHECK(frame->format() == media::PIXEL_FORMAT_I420 ||
+         frame->format() == media::PIXEL_FORMAT_YV12);
 
   libyuv::I420Scale(
       lastFrame_->visible_data(VideoFrame::kYPlane),
@@ -272,4 +272,4 @@ void ScreenCaptureMachineAndroid::MaybeCaptureForRefresh() {
   capture_frame_cb.Run(frame, start_time, true);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/android/screen_capture_machine_android.h b/device/capture/content/android/screen_capture_machine_android.h
similarity index 73%
rename from media/capture/content/android/screen_capture_machine_android.h
rename to device/capture/content/android/screen_capture_machine_android.h
index 84bf1c7..c2c2166 100644
--- a/media/capture/content/android/screen_capture_machine_android.h
+++ b/device/capture/content/android/screen_capture_machine_android.h
@@ -2,19 +2,20 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_MACHINE_ANDROID_H_
-#define MEDIA_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_MACHINE_ANDROID_H_
+#ifndef DEVICE_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_MACHINE_ANDROID_H_
+#define DEVICE_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_MACHINE_ANDROID_H_
 
 #include <jni.h>
 #include <memory>
 
 #include "base/android/scoped_java_ref.h"
-#include "media/capture/content/screen_capture_device_core.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/content/screen_capture_device_core.h"
 
-namespace media {
+namespace device {
 
 // ScreenCaptureMachineAndroid captures 32bit RGB or YUV420 triplanar.
-class ScreenCaptureMachineAndroid : public media::VideoCaptureMachine {
+class CAPTURE_EXPORT ScreenCaptureMachineAndroid : public VideoCaptureMachine {
  public:
   ScreenCaptureMachineAndroid();
   ~ScreenCaptureMachineAndroid() override;
@@ -23,7 +24,7 @@ class ScreenCaptureMachineAndroid : public media::VideoCaptureMachine {
   static base::android::ScopedJavaLocalRef<jobject>
   createScreenCaptureMachineAndroid(jlong nativeScreenCaptureMachineAndroid);
 
-  // Implement org.chromium.media.ScreenCapture.nativeOnRGBAFrameAvailable.
+  // Implement org.chromium.device.ScreenCapture.nativeOnRGBAFrameAvailable.
   void OnRGBAFrameAvailable(JNIEnv* env,
                             jobject obj,
                             jobject buf,
@@ -33,7 +34,7 @@ class ScreenCaptureMachineAndroid : public media::VideoCaptureMachine {
                             jint width,
                             jint height,
                             jlong timestamp);
-  // Implement org.chromium.media.ScreenCapture.nativeOnI420FrameAvailable.
+  // Implement org.chromium.device.ScreenCapture.nativeOnI420FrameAvailable.
   void OnI420FrameAvailable(JNIEnv* env,
                             jobject obj,
                             jobject y_buffer,
@@ -48,11 +49,11 @@ class ScreenCaptureMachineAndroid : public media::VideoCaptureMachine {
                             jint height,
                             jlong timestamp);
 
-  // Implement org.chromium.media.ScreenCapture.nativeOnActivityResult.
+  // Implement org.chromium.device.ScreenCapture.nativeOnActivityResult.
   void OnActivityResult(JNIEnv* env, jobject obj, jboolean result);
 
   // VideoCaptureMachine overrides.
-  void Start(const scoped_refptr<media::ThreadSafeCaptureOracle>& oracle_proxy,
+  void Start(const scoped_refptr<ThreadSafeCaptureOracle>& oracle_proxy,
              const media::VideoCaptureParams& params,
              const base::Callback<void(bool)> callback) override;
   void Stop(const base::Closure& callback) override;
@@ -60,7 +61,7 @@ class ScreenCaptureMachineAndroid : public media::VideoCaptureMachine {
 
  private:
   // Makes all the decisions about which frames to copy, and how.
-  scoped_refptr<media::ThreadSafeCaptureOracle> oracle_proxy_;
+  scoped_refptr<ThreadSafeCaptureOracle> oracle_proxy_;
 
   // Cache the last frame for possible refreshing.
   scoped_refptr<VideoFrame> lastFrame_;
@@ -71,6 +72,6 @@ class ScreenCaptureMachineAndroid : public media::VideoCaptureMachine {
   DISALLOW_COPY_AND_ASSIGN(ScreenCaptureMachineAndroid);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_MACHINE_ANDROID_H_
+#endif  // DEVICE_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_MACHINE_ANDROID_H_
diff --git a/media/capture/content/animated_content_sampler.cc b/device/capture/content/animated_content_sampler.cc
similarity index 99%
rename from media/capture/content/animated_content_sampler.cc
rename to device/capture/content/animated_content_sampler.cc
index 7f09cd1..7b70108 100644
--- a/media/capture/content/animated_content_sampler.cc
+++ b/device/capture/content/animated_content_sampler.cc
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/animated_content_sampler.h"
+#include "device/capture/content/animated_content_sampler.h"
 
 #include <stddef.h>
 #include <stdint.h>
 
 #include <algorithm>
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -293,4 +293,4 @@ base::TimeDelta AnimatedContentSampler::ComputeSamplingPeriod(
   return std::max(sampling_period, min_capture_period);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/animated_content_sampler.h b/device/capture/content/animated_content_sampler.h
similarity index 96%
rename from media/capture/content/animated_content_sampler.h
rename to device/capture/content/animated_content_sampler.h
index 0539de7..503e031 100644
--- a/media/capture/content/animated_content_sampler.h
+++ b/device/capture/content/animated_content_sampler.h
@@ -2,16 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_ANIMATED_CONTENT_SAMPLER_H_
-#define MEDIA_CAPTURE_CONTENT_ANIMATED_CONTENT_SAMPLER_H_
+#ifndef DEVICE_CAPTURE_CONTENT_ANIMATED_CONTENT_SAMPLER_H_
+#define DEVICE_CAPTURE_CONTENT_ANIMATED_CONTENT_SAMPLER_H_
 
 #include <deque>
 
 #include "base/time/time.h"
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 #include "ui/gfx/geometry/rect.h"
 
-namespace media {
+namespace device {
 
 // Analyzes a sequence of events to detect the presence of constant frame rate
 // animated content.  In the case where there are multiple regions of animated
@@ -152,6 +152,6 @@ class CAPTURE_EXPORT AnimatedContentSampler {
   base::TimeTicks frame_timestamp_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_ANIMATED_CONTENT_SAMPLER_H_
+#endif  // DEVICE_CAPTURE_CONTENT_ANIMATED_CONTENT_SAMPLER_H_
diff --git a/media/capture/content/animated_content_sampler_unittest.cc b/device/capture/content/animated_content_sampler_unittest.cc
similarity index 99%
rename from media/capture/content/animated_content_sampler_unittest.cc
rename to device/capture/content/animated_content_sampler_unittest.cc
index 1a8766c..5a08936 100644
--- a/media/capture/content/animated_content_sampler_unittest.cc
+++ b/device/capture/content/animated_content_sampler_unittest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/animated_content_sampler.h"
+#include "device/capture/content/animated_content_sampler.h"
 
 #include <stddef.h>
 #include <stdint.h>
@@ -17,7 +17,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "ui/gfx/geometry/rect.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -750,4 +750,4 @@ INSTANTIATE_TEST_CASE_P(
         Scenario(60, 30, 32),
         Scenario(60, 30, 33)));
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/capture_resolution_chooser.cc b/device/capture/content/capture_resolution_chooser.cc
similarity index 90%
rename from media/capture/content/capture_resolution_chooser.cc
rename to device/capture/content/capture_resolution_chooser.cc
index 3c7f3e5..f7242e0 100644
--- a/media/capture/content/capture_resolution_chooser.cc
+++ b/device/capture/content/capture_resolution_chooser.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/capture_resolution_chooser.h"
+#include "device/capture/content/capture_resolution_chooser.h"
 
 #include <algorithm>
 #include <limits>
@@ -11,7 +11,7 @@
 #include "media/base/limits.h"
 #include "media/base/video_util.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -33,9 +33,9 @@ gfx::Size ComputeMinimumCaptureSize(
     const gfx::Size& max_frame_size,
     ResolutionChangePolicy resolution_change_policy) {
   switch (resolution_change_policy) {
-    case RESOLUTION_POLICY_FIXED_RESOLUTION:
+    case media::RESOLUTION_POLICY_FIXED_RESOLUTION:
       return max_frame_size;
-    case RESOLUTION_POLICY_FIXED_ASPECT_RATIO: {
+    case media::RESOLUTION_POLICY_FIXED_ASPECT_RATIO: {
       // TODO(miu): This is a place-holder until "min constraints" are plumbed-
       // in from the MediaStream framework.  http://crbug.com/473336
       const int kMinLines = 180;
@@ -44,11 +44,11 @@ gfx::Size ComputeMinimumCaptureSize(
       const gfx::Size result(
           kMinLines * max_frame_size.width() / max_frame_size.height(),
           kMinLines);
-      if (result.width() <= 0 || result.width() > limits::kMaxDimension)
+      if (result.width() <= 0 || result.width() > media::limits::kMaxDimension)
         return max_frame_size;
       return result;
     }
-    case RESOLUTION_POLICY_ANY_WITHIN_LIMIT:
+    case media::RESOLUTION_POLICY_ANY_WITHIN_LIMIT:
       return gfx::Size(1, 1);
   }
   NOTREACHED();
@@ -62,12 +62,12 @@ gfx::Size ComputeBoundedCaptureSize(const gfx::Size& size,
                                     const gfx::Size& min_size,
                                     const gfx::Size& max_size) {
   if (size.width() > max_size.width() || size.height() > max_size.height()) {
-    gfx::Size result = ScaleSizeToFitWithinTarget(size, max_size);
+    gfx::Size result = media::ScaleSizeToFitWithinTarget(size, max_size);
     result.SetToMax(min_size);
     return result;
   } else if (size.width() < min_size.width() ||
              size.height() < min_size.height()) {
-    gfx::Size result = ScaleSizeToEncompassTarget(size, min_size);
+    gfx::Size result = media::ScaleSizeToEncompassTarget(size, min_size);
     result.SetToMin(max_size);
     return result;
   } else {
@@ -94,7 +94,7 @@ CaptureResolutionChooser::CaptureResolutionChooser(
   DCHECK_LT(0, max_frame_size_.height());
   DCHECK_LE(min_frame_size_.width(), max_frame_size_.width());
   DCHECK_LE(min_frame_size_.height(), max_frame_size_.height());
-  DCHECK_LE(resolution_change_policy_, RESOLUTION_POLICY_LAST);
+  DCHECK_LE(resolution_change_policy_, media::RESOLUTION_POLICY_LAST);
 
   UpdateSnappedFrameSizes(max_frame_size_);
   RecomputeCaptureSize();
@@ -108,19 +108,19 @@ void CaptureResolutionChooser::SetSourceSize(const gfx::Size& source_size) {
     return;
 
   switch (resolution_change_policy_) {
-    case RESOLUTION_POLICY_FIXED_RESOLUTION:
+    case media::RESOLUTION_POLICY_FIXED_RESOLUTION:
       // Source size changes do not affect the frame resolution.  Frame
       // resolution is always fixed to |max_frame_size_|.
       break;
 
-    case RESOLUTION_POLICY_FIXED_ASPECT_RATIO:
+    case media::RESOLUTION_POLICY_FIXED_ASPECT_RATIO:
       UpdateSnappedFrameSizes(ComputeBoundedCaptureSize(
-          PadToMatchAspectRatio(source_size, max_frame_size_), min_frame_size_,
-          max_frame_size_));
+          media::PadToMatchAspectRatio(source_size, max_frame_size_),
+          min_frame_size_, max_frame_size_));
       RecomputeCaptureSize();
       break;
 
-    case RESOLUTION_POLICY_ANY_WITHIN_LIMIT:
+    case media::RESOLUTION_POLICY_ANY_WITHIN_LIMIT:
       UpdateSnappedFrameSizes(ComputeBoundedCaptureSize(
           source_size, min_frame_size_, max_frame_size_));
       RecomputeCaptureSize();
@@ -236,4 +236,4 @@ void CaptureResolutionChooser::UpdateSnappedFrameSizes(
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/capture_resolution_chooser.h b/device/capture/content/capture_resolution_chooser.h
similarity index 92%
rename from media/capture/content/capture_resolution_chooser.h
rename to device/capture/content/capture_resolution_chooser.h
index cbc887d..91a603d 100644
--- a/media/capture/content/capture_resolution_chooser.h
+++ b/device/capture/content/capture_resolution_chooser.h
@@ -2,16 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_CAPTURE_RESOLUTION_CHOOSER_H_
-#define MEDIA_CAPTURE_CONTENT_CAPTURE_RESOLUTION_CHOOSER_H_
+#ifndef DEVICE_CAPTURE_CONTENT_CAPTURE_RESOLUTION_CHOOSER_H_
+#define DEVICE_CAPTURE_CONTENT_CAPTURE_RESOLUTION_CHOOSER_H_
 
 #include <vector>
 
+#include "device/capture/capture_export.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/capture_export.h"
 #include "ui/gfx/geometry/size.h"
 
-namespace media {
+namespace device {
+using media::ResolutionChangePolicy;
 
 // Encapsulates the logic that determines the capture frame resolution based on:
 //   1. The configured maximum frame resolution and resolution change policy.
@@ -86,6 +87,6 @@ class CAPTURE_EXPORT CaptureResolutionChooser {
   std::vector<gfx::Size> snapped_sizes_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_CAPTURE_RESOLUTION_CHOOSER_H_
+#endif  // DEVICE_CAPTURE_CONTENT_CAPTURE_RESOLUTION_CHOOSER_H_
diff --git a/media/capture/content/capture_resolution_chooser_unittest.cc b/device/capture/content/capture_resolution_chooser_unittest.cc
similarity index 97%
rename from media/capture/content/capture_resolution_chooser_unittest.cc
rename to device/capture/content/capture_resolution_chooser_unittest.cc
index a0346b1..7d61a1a 100644
--- a/media/capture/content/capture_resolution_chooser_unittest.cc
+++ b/device/capture/content/capture_resolution_chooser_unittest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/capture_resolution_chooser.h"
+#include "device/capture/content/capture_resolution_chooser.h"
 
 #include <stddef.h>
 
@@ -12,7 +12,7 @@
 
 using tracked_objects::Location;
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -192,7 +192,7 @@ TEST(CaptureResolutionChooserTest,
      FixedResolutionPolicy_CaptureSizeAlwaysFixed) {
   const gfx::Size the_one_frame_size(kMaxFrameWidth, kMaxFrameHeight);
   CaptureResolutionChooser chooser(the_one_frame_size,
-                                   RESOLUTION_POLICY_FIXED_RESOLUTION);
+                                   media::RESOLUTION_POLICY_FIXED_RESOLUTION);
   EXPECT_EQ(the_one_frame_size, chooser.capture_size());
 
   chooser.SetSourceSize(the_one_frame_size);
@@ -229,7 +229,7 @@ TEST(CaptureResolutionChooserTest,
 TEST(CaptureResolutionChooserTest,
      FixedAspectRatioPolicy_CaptureSizeHasSameAspectRatio) {
   CaptureResolutionChooser chooser(gfx::Size(kMaxFrameWidth, kMaxFrameHeight),
-                                   RESOLUTION_POLICY_FIXED_ASPECT_RATIO);
+                                   media::RESOLUTION_POLICY_FIXED_ASPECT_RATIO);
 
   // Starting condition.
   const gfx::Size min_size(kMinFrameWidth, kMinFrameHeight);
@@ -301,7 +301,7 @@ TEST(CaptureResolutionChooserTest,
      AnyWithinLimitPolicy_CaptureSizeIsAnythingWithinLimits) {
   const gfx::Size max_size(kMaxFrameWidth, kMaxFrameHeight);
   CaptureResolutionChooser chooser(max_size,
-                                   RESOLUTION_POLICY_ANY_WITHIN_LIMIT);
+                                   media::RESOLUTION_POLICY_ANY_WITHIN_LIMIT);
 
   // Starting condition.
   EXPECT_EQ(max_size, chooser.capture_size());
@@ -350,4 +350,4 @@ TEST(CaptureResolutionChooserTest,
   TestTargetedFrameAreas(&chooser, smallest_size);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/screen_capture_device_core.cc b/device/capture/content/screen_capture_device_core.cc
similarity index 93%
rename from media/capture/content/screen_capture_device_core.cc
rename to device/capture/content/screen_capture_device_core.cc
index 0f06dfa..e08bb55 100644
--- a/media/capture/content/screen_capture_device_core.cc
+++ b/device/capture/content/screen_capture_device_core.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/screen_capture_device_core.h"
+#include "device/capture/content/screen_capture_device_core.h"
 
 #include <memory>
 #include <utility>
@@ -15,7 +15,7 @@
 #include "base/strings/stringprintf.h"
 #include "base/threading/thread_checker.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -46,8 +46,8 @@ void ScreenCaptureDeviceCore::AllocateAndStart(
     return;
   }
 
-  if (params.requested_format.pixel_format != PIXEL_FORMAT_I420 ||
-      params.requested_format.pixel_storage != PIXEL_STORAGE_CPU) {
+  if (params.requested_format.pixel_format != media::PIXEL_FORMAT_I420 ||
+      params.requested_format.pixel_storage != media::PIXEL_STORAGE_CPU) {
     client->OnError(
         FROM_HERE,
         base::StringPrintf(
@@ -141,4 +141,4 @@ void ScreenCaptureDeviceCore::Error(const tracked_objects::Location& from_here,
   TransitionStateTo(kError);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/screen_capture_device_core.h b/device/capture/content/screen_capture_device_core.h
similarity index 91%
rename from media/capture/content/screen_capture_device_core.h
rename to device/capture/content/screen_capture_device_core.h
index 3f8884b..300002c 100644
--- a/media/capture/content/screen_capture_device_core.h
+++ b/device/capture/content/screen_capture_device_core.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_SCREEN_CAPTURE_DEVICE_CORE_H_
-#define MEDIA_CAPTURE_CONTENT_SCREEN_CAPTURE_DEVICE_CORE_H_
+#ifndef DEVICE_CAPTURE_CONTENT_SCREEN_CAPTURE_DEVICE_CORE_H_
+#define DEVICE_CAPTURE_CONTENT_SCREEN_CAPTURE_DEVICE_CORE_H_
 
 #include <memory>
 #include <string>
@@ -11,17 +11,19 @@
 #include "base/macros.h"
 #include "base/memory/weak_ptr.h"
 #include "base/threading/thread_checker.h"
-#include "media/capture/capture_export.h"
-#include "media/capture/content/thread_safe_capture_oracle.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/content/thread_safe_capture_oracle.h"
+#include "device/capture/video/video_capture_device.h"
+
+namespace media {
+struct VideoCaptureParams;
+}  // namespace media
 
 namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
-
-struct VideoCaptureParams;
+namespace device {
 
 class ThreadSafeCaptureOracle;
 
@@ -117,6 +119,6 @@ class CAPTURE_EXPORT ScreenCaptureDeviceCore
   DISALLOW_COPY_AND_ASSIGN(ScreenCaptureDeviceCore);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_SCREEN_CAPTURE_DEVICE_CORE_H_
+#endif  // DEVICE_CAPTURE_CONTENT_SCREEN_CAPTURE_DEVICE_CORE_H_
diff --git a/media/capture/content/smooth_event_sampler.cc b/device/capture/content/smooth_event_sampler.cc
similarity index 95%
rename from media/capture/content/smooth_event_sampler.cc
rename to device/capture/content/smooth_event_sampler.cc
index 7f7297f..208221b 100644
--- a/media/capture/content/smooth_event_sampler.cc
+++ b/device/capture/content/smooth_event_sampler.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/smooth_event_sampler.h"
+#include "device/capture/content/smooth_event_sampler.h"
 
 #include <stdint.h>
 
@@ -10,7 +10,7 @@
 
 #include "base/trace_event/trace_event.h"
 
-namespace media {
+namespace device {
 
 SmoothEventSampler::SmoothEventSampler(base::TimeDelta min_capture_period)
     : token_bucket_(base::TimeDelta::Max()) {
@@ -64,4 +64,4 @@ bool SmoothEventSampler::HasUnrecordedEvent() const {
   return !current_event_.is_null() && current_event_ != last_sample_;
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/smooth_event_sampler.h b/device/capture/content/smooth_event_sampler.h
similarity index 86%
rename from media/capture/content/smooth_event_sampler.h
rename to device/capture/content/smooth_event_sampler.h
index 47ed58e..fb42d47 100644
--- a/media/capture/content/smooth_event_sampler.h
+++ b/device/capture/content/smooth_event_sampler.h
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_SMOOTH_EVENT_SAMPLER_H_
-#define MEDIA_CAPTURE_CONTENT_SMOOTH_EVENT_SAMPLER_H_
+#ifndef DEVICE_CAPTURE_CONTENT_SMOOTH_EVENT_SAMPLER_H_
+#define DEVICE_CAPTURE_CONTENT_SMOOTH_EVENT_SAMPLER_H_
 
 #include "base/macros.h"
 #include "base/time/time.h"
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 
-namespace media {
+namespace device {
 
 // Filters a sequence of events to achieve a target frequency.
 class CAPTURE_EXPORT SmoothEventSampler {
@@ -49,6 +49,6 @@ class CAPTURE_EXPORT SmoothEventSampler {
   DISALLOW_COPY_AND_ASSIGN(SmoothEventSampler);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_SMOOTH_EVENT_SAMPLER_H_
+#endif  // DEVICE_CAPTURE_CONTENT_SMOOTH_EVENT_SAMPLER_H_
diff --git a/media/capture/content/smooth_event_sampler_unittest.cc b/device/capture/content/smooth_event_sampler_unittest.cc
similarity index 99%
rename from media/capture/content/smooth_event_sampler_unittest.cc
rename to device/capture/content/smooth_event_sampler_unittest.cc
index abd7d4c..b4e7f38 100644
--- a/media/capture/content/smooth_event_sampler_unittest.cc
+++ b/device/capture/content/smooth_event_sampler_unittest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/smooth_event_sampler.h"
+#include "device/capture/content/smooth_event_sampler.h"
 
 #include <stddef.h>
 #include <stdint.h>
@@ -11,7 +11,7 @@
 #include "base/strings/stringprintf.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -614,4 +614,4 @@ TEST(SmoothEventSamplerTest, DrawingAt60FpsWith60HzVsyncSampledAt30Hertz) {
   ReplayCheckingSamplerDecisions(data_points, arraysize(data_points), &sampler);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/thread_safe_capture_oracle.cc b/device/capture/content/thread_safe_capture_oracle.cc
similarity index 98%
rename from media/capture/content/thread_safe_capture_oracle.cc
rename to device/capture/content/thread_safe_capture_oracle.cc
index 6cd4048..9c116f1 100644
--- a/media/capture/content/thread_safe_capture_oracle.cc
+++ b/device/capture/content/thread_safe_capture_oracle.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/thread_safe_capture_oracle.h"
+#include "device/capture/content/thread_safe_capture_oracle.h"
 
 #include <stdint.h>
 
@@ -22,7 +22,7 @@
 #include "media/base/video_util.h"
 #include "ui/gfx/geometry/rect.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -61,7 +61,7 @@ bool ThreadSafeCaptureOracle::ObserveEventAndDecideCapture(
 
   gfx::Size visible_size;
   gfx::Size coded_size;
-  std::unique_ptr<media::VideoCaptureDevice::Client::Buffer> output_buffer;
+  std::unique_ptr<VideoCaptureDevice::Client::Buffer> output_buffer;
   double attenuated_utilization;
   int frame_number;
   base::TimeDelta estimated_frame_duration;
@@ -249,4 +249,4 @@ void ThreadSafeCaptureOracle::DidConsumeFrame(
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/thread_safe_capture_oracle.h b/device/capture/content/thread_safe_capture_oracle.h
similarity index 92%
rename from media/capture/content/thread_safe_capture_oracle.h
rename to device/capture/content/thread_safe_capture_oracle.h
index f54315b..e3079ee 100644
--- a/media/capture/content/thread_safe_capture_oracle.h
+++ b/device/capture/content/thread_safe_capture_oracle.h
@@ -2,26 +2,28 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_THREAD_SAFE_CAPTURE_ORACLE_H_
-#define MEDIA_CAPTURE_CONTENT_THREAD_SAFE_CAPTURE_ORACLE_H_
+#ifndef DEVICE_CAPTURE_CONTENT_THREAD_SAFE_CAPTURE_ORACLE_H_
+#define DEVICE_CAPTURE_CONTENT_THREAD_SAFE_CAPTURE_ORACLE_H_
 
 #include <memory>
 #include <string>
 
 #include "base/memory/ref_counted.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/content/video_capture_oracle.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/base/video_frame.h"
-#include "media/capture/capture_export.h"
-#include "media/capture/content/video_capture_oracle.h"
-#include "media/capture/video/video_capture_device.h"
+
+namespace media {
+struct VideoCaptureParams;
+class VideoFrame;
+}  // namespace media
 
 namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
-
-struct VideoCaptureParams;
-class VideoFrame;
+namespace device {
 
 // Thread-safe, refcounted proxy to the VideoCaptureOracle.  This proxy wraps
 // the VideoCaptureOracle, which decides which frames to capture, and a
@@ -122,6 +124,6 @@ class CAPTURE_EXPORT ThreadSafeCaptureOracle
   const VideoCaptureParams params_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_THREAD_SAFE_CAPTURE_ORACLE_H_
+#endif  // DEVICE_CAPTURE_CONTENT_THREAD_SAFE_CAPTURE_ORACLE_H_
diff --git a/media/capture/content/video_capture_oracle.cc b/device/capture/content/video_capture_oracle.cc
similarity index 99%
rename from media/capture/content/video_capture_oracle.cc
rename to device/capture/content/video_capture_oracle.cc
index e8dd752..f2e63c1 100644
--- a/media/capture/content/video_capture_oracle.cc
+++ b/device/capture/content/video_capture_oracle.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/video_capture_oracle.h"
+#include "device/capture/content/video_capture_oracle.h"
 
 #include <algorithm>
 
@@ -10,7 +10,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/strings/stringprintf.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -83,7 +83,7 @@ base::TimeTicks JustAfter(base::TimeTicks t) {
 // sufficient amount of time and the latest update was fairly recent, relative
 // to |now|.
 bool HasSufficientRecentFeedback(
-    const FeedbackSignalAccumulator<base::TimeTicks>& accumulator,
+    const media::FeedbackSignalAccumulator<base::TimeTicks>& accumulator,
     base::TimeTicks now) {
   const base::TimeDelta amount_of_history =
       accumulator.update_time() - accumulator.reset_time();
@@ -554,4 +554,4 @@ int VideoCaptureOracle::AnalyzeForIncreasedArea(base::TimeTicks analyze_time) {
   return increased_area;
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/content/video_capture_oracle.h b/device/capture/content/video_capture_oracle.h
similarity index 93%
rename from media/capture/content/video_capture_oracle.h
rename to device/capture/content/video_capture_oracle.h
index 82898f9..1700591 100644
--- a/media/capture/content/video_capture_oracle.h
+++ b/device/capture/content/video_capture_oracle.h
@@ -2,19 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_CONTENT_VIDEO_CAPTURE_ORACLE_H_
-#define MEDIA_CAPTURE_CONTENT_VIDEO_CAPTURE_ORACLE_H_
+#ifndef DEVICE_CAPTURE_CONTENT_VIDEO_CAPTURE_ORACLE_H_
+#define DEVICE_CAPTURE_CONTENT_VIDEO_CAPTURE_ORACLE_H_
 
 #include "base/callback_forward.h"
 #include "base/time/time.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/content/animated_content_sampler.h"
+#include "device/capture/content/capture_resolution_chooser.h"
+#include "device/capture/content/smooth_event_sampler.h"
 #include "media/base/feedback_signal_accumulator.h"
-#include "media/capture/capture_export.h"
-#include "media/capture/content/animated_content_sampler.h"
-#include "media/capture/content/capture_resolution_chooser.h"
-#include "media/capture/content/smooth_event_sampler.h"
 #include "ui/gfx/geometry/rect.h"
 
-namespace media {
+namespace device {
 
 // VideoCaptureOracle manages the producer-side throttling of captured frames
 // from a video capture device.  It is informed of every update by the device;
@@ -180,13 +180,13 @@ class CAPTURE_EXPORT VideoCaptureOracle {
   base::TimeTicks frame_timestamps_[kMaxFrameTimestamps];
 
   // Recent average buffer pool utilization for capture.
-  FeedbackSignalAccumulator<base::TimeTicks> buffer_pool_utilization_;
+  media::FeedbackSignalAccumulator<base::TimeTicks> buffer_pool_utilization_;
 
   // Estimated maximum frame area that currently can be handled by the consumer,
   // in number of pixels per frame.  This is used to adjust the capture size up
   // or down to a data volume the consumer can handle.  Note that some consumers
   // do not provide feedback, and the analysis logic should account for that.
-  FeedbackSignalAccumulator<base::TimeTicks> estimated_capable_area_;
+  media::FeedbackSignalAccumulator<base::TimeTicks> estimated_capable_area_;
 
   // The time of the first analysis which concluded the end-to-end system was
   // under-utilized.  If null, the system is not currently under-utilized.  This
@@ -200,6 +200,6 @@ class CAPTURE_EXPORT VideoCaptureOracle {
   base::TimeTicks last_time_animation_was_detected_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_CONTENT_VIDEO_CAPTURE_ORACLE_H_
+#endif  // DEVICE_CAPTURE_CONTENT_VIDEO_CAPTURE_ORACLE_H_
diff --git a/media/capture/content/video_capture_oracle_unittest.cc b/device/capture/content/video_capture_oracle_unittest.cc
similarity index 99%
rename from media/capture/content/video_capture_oracle_unittest.cc
rename to device/capture/content/video_capture_oracle_unittest.cc
index dbfcae2..99e8338 100644
--- a/media/capture/content/video_capture_oracle_unittest.cc
+++ b/device/capture/content/video_capture_oracle_unittest.cc
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/content/video_capture_oracle.h"
+#include "device/capture/content/video_capture_oracle.h"
 
 #include "base/strings/stringprintf.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -616,4 +616,4 @@ TEST(VideoCaptureOracleTest, DoesNotAutoThrottleWhenResolutionIsFixed) {
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/device_monitor_mac.h b/device/capture/device_monitor_mac.h
similarity index 89%
rename from media/capture/device_monitor_mac.h
rename to device/capture/device_monitor_mac.h
index c6db8b9..feed8c8 100644
--- a/media/capture/device_monitor_mac.h
+++ b/device/capture/device_monitor_mac.h
@@ -2,21 +2,21 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_DEVICE_MONITOR_MAC_H_
-#define MEDIA_CAPTURE_DEVICE_MONITOR_MAC_H_
+#ifndef DEVICE_CAPTURE_DEVICE_MONITOR_MAC_H_
+#define DEVICE_CAPTURE_DEVICE_MONITOR_MAC_H_
 
 #include <memory>
 
 #include "base/macros.h"
 #include "base/system_monitor/system_monitor.h"
 #include "base/threading/thread_checker.h"
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 
 namespace {
 class DeviceMonitorMacImpl;
 }
 
-namespace media {
+namespace device {
 
 // Class to track audio/video devices removal or addition via callback to
 // base::SystemMonitor ProcessDevicesChanged(). A single object of this class
@@ -50,4 +50,4 @@ class CAPTURE_EXPORT DeviceMonitorMac {
 
 }  // namespace content
 
-#endif  // MEDIA_CAPTURE_DEVICE_MONITOR_MAC_H_
+#endif  // DEVICE_CAPTURE_DEVICE_MONITOR_MAC_H_
diff --git a/media/capture/device_monitor_mac.mm b/device/capture/device_monitor_mac.mm
similarity index 99%
rename from media/capture/device_monitor_mac.mm
rename to device/capture/device_monitor_mac.mm
index 2ff63e0..29ec66d 100644
--- a/media/capture/device_monitor_mac.mm
+++ b/device/capture/device_monitor_mac.mm
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/device_monitor_mac.h"
+#include "device/capture/device_monitor_mac.h"
 
 #include <set>
 
@@ -437,7 +437,7 @@ void AVFoundationMonitorImpl::OnDeviceChanged() {
 
 @end  // @implementation CrAVFoundationDeviceObserver
 
-namespace media {
+namespace device {
 
 DeviceMonitorMac::DeviceMonitorMac() {
   // AVFoundation do not need to be fired up until the user
@@ -472,4 +472,4 @@ void DeviceMonitorMac::NotifyDeviceChanged(
   base::SystemMonitor::Get()->ProcessDevicesChanged(type);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/device_monitor_udev.cc b/device/capture/device_monitor_udev.cc
similarity index 96%
rename from media/capture/device_monitor_udev.cc
rename to device/capture/device_monitor_udev.cc
index a010427..908699d 100644
--- a/media/capture/device_monitor_udev.cc
+++ b/device/capture/device_monitor_udev.cc
@@ -4,7 +4,7 @@
 
 // libudev is used for monitoring device changes.
 
-#include "media/capture/device_monitor_udev.h"
+#include "device/capture/device_monitor_udev.h"
 
 #include <stddef.h>
 
@@ -34,7 +34,7 @@ const SubsystemMap kSubsystemMap[] = {
 
 }  // namespace
 
-namespace media {
+namespace device {
 
 DeviceMonitorLinux::DeviceMonitorLinux(
     const scoped_refptr<base::SingleThreadTaskRunner>& io_task_runner)
@@ -85,4 +85,4 @@ void DeviceMonitorLinux::OnDevicesChanged(udev_device* device) {
   base::SystemMonitor::Get()->ProcessDevicesChanged(device_type);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/device_monitor_udev.h b/device/capture/device_monitor_udev.h
similarity index 85%
rename from media/capture/device_monitor_udev.h
rename to device/capture/device_monitor_udev.h
index a8f9d82..6536d34 100644
--- a/media/capture/device_monitor_udev.h
+++ b/device/capture/device_monitor_udev.h
@@ -5,8 +5,8 @@
 // This class is used to detect device change and notify base::SystemMonitor
 // on Linux.
 
-#ifndef MEDIA_CAPTURE_DEVICE_MONITOR_UDEV_H_
-#define MEDIA_CAPTURE_DEVICE_MONITOR_UDEV_H_
+#ifndef DEVICE_CAPTURE_DEVICE_MONITOR_UDEV_H_
+#define DEVICE_CAPTURE_DEVICE_MONITOR_UDEV_H_
 
 #include <memory>
 
@@ -14,7 +14,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/message_loop/message_loop.h"
 #include "base/single_thread_task_runner.h"
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 
 extern "C" {
 struct udev_device;
@@ -24,7 +24,7 @@ namespace device {
 class UdevLinux;
 }
 
-namespace media {
+namespace device {
 
 class CAPTURE_EXPORT DeviceMonitorLinux
     : public base::MessageLoop::DestructionObserver {
@@ -52,6 +52,6 @@ class CAPTURE_EXPORT DeviceMonitorLinux
   DISALLOW_COPY_AND_ASSIGN(DeviceMonitorLinux);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_DEVICE_MONITOR_UDEV_H_
+#endif  // DEVICE_CAPTURE_DEVICE_MONITOR_UDEV_H_
diff --git a/media/capture/system_message_window_win.cc b/device/capture/system_message_window_win.cc
similarity index 98%
rename from media/capture/system_message_window_win.cc
rename to device/capture/system_message_window_win.cc
index 66ebb3e..5f682b5 100644
--- a/media/capture/system_message_window_win.cc
+++ b/device/capture/system_message_window_win.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/system_message_window_win.h"
+#include "device/capture/system_message_window_win.h"
 
 #include <dbt.h>
 #include <stddef.h>
@@ -13,7 +13,7 @@
 #include "base/win/wrapped_window_proc.h"
 #include "media/audio/win/core_audio_util_win.h"
 
-namespace media {
+namespace device {
 
 namespace {
 const wchar_t kWindowClassName[] = L"Chrome_SystemMessageWindow";
@@ -156,4 +156,4 @@ LRESULT CALLBACK SystemMessageWindowWin::WndProc(HWND hwnd,
   return ::DefWindowProc(hwnd, message, wparam, lparam);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/system_message_window_win.h b/device/capture/system_message_window_win.h
similarity index 84%
rename from media/capture/system_message_window_win.h
rename to device/capture/system_message_window_win.h
index 6468317..41f11db 100644
--- a/media/capture/system_message_window_win.h
+++ b/device/capture/system_message_window_win.h
@@ -2,17 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_SYSTEM_MESSAGE_WINDOW_WIN_H_
-#define MEDIA_CAPTURE_SYSTEM_MESSAGE_WINDOW_WIN_H_
+#ifndef DEVICE_CAPTURE_SYSTEM_MESSAGE_WINDOW_WIN_H_
+#define DEVICE_CAPTURE_SYSTEM_MESSAGE_WINDOW_WIN_H_
 
 #include <windows.h>
 
 #include <memory>
 
 #include "base/macros.h"
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 
-namespace media {
+namespace device {
 
 class CAPTURE_EXPORT SystemMessageWindowWin {
  public:
@@ -49,6 +49,6 @@ class CAPTURE_EXPORT SystemMessageWindowWin {
   DISALLOW_COPY_AND_ASSIGN(SystemMessageWindowWin);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_SYSTEM_MESSAGE_WINDOW_WIN_H_
+#endif  // DEVICE_CAPTURE_SYSTEM_MESSAGE_WINDOW_WIN_H_
diff --git a/media/capture/system_message_window_win_unittest.cc b/device/capture/system_message_window_win_unittest.cc
similarity index 92%
rename from media/capture/system_message_window_win_unittest.cc
rename to device/capture/system_message_window_win_unittest.cc
index 80ff75c..522f1d7 100644
--- a/media/capture/system_message_window_win_unittest.cc
+++ b/device/capture/system_message_window_win_unittest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/system_message_window_win.h"
+#include "device/capture/system_message_window_win.h"
 
 #include <dbt.h>
 #include <string>
@@ -15,7 +15,7 @@
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace media {
+namespace device {
 
 class SystemMessageWindowWinTest : public testing::Test {
  public:
@@ -43,4 +43,4 @@ TEST_F(SystemMessageWindowWinTest, RandomMessage) {
   message_loop_.RunUntilIdle();
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/OWNERS b/device/capture/video/OWNERS
similarity index 100%
rename from media/capture/video/OWNERS
rename to device/capture/video/OWNERS
diff --git a/media/capture/video/android/capture_jni_registrar.cc b/device/capture/video/android/capture_jni_registrar.cc
similarity index 77%
rename from media/capture/video/android/capture_jni_registrar.cc
rename to device/capture/video/android/capture_jni_registrar.cc
index 551db1a..cf04a04 100644
--- a/media/capture/video/android/capture_jni_registrar.cc
+++ b/device/capture/video/android/capture_jni_registrar.cc
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/android/capture_jni_registrar.h"
+#include "device/capture/video/android/capture_jni_registrar.h"
 
 #include "base/android/jni_android.h"
 #include "base/android/jni_registrar.h"
 #include "base/macros.h"
-#include "media/capture/video/android/video_capture_device_android.h"
+#include "device/capture/video/android/video_capture_device_android.h"
 
-namespace media {
+namespace device {
 
 static base::android::RegistrationMethod kCaptureRegisteredMethods[] = {
     {"VideoCaptureDevice",
@@ -21,4 +21,4 @@ bool RegisterCaptureJni(JNIEnv* env) {
       env, kCaptureRegisteredMethods, arraysize(kCaptureRegisteredMethods));
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/android/capture_jni_registrar.h b/device/capture/video/android/capture_jni_registrar.h
similarity index 51%
rename from media/capture/video/android/capture_jni_registrar.h
rename to device/capture/video/android/capture_jni_registrar.h
index 361c5ab..542b2fb 100644
--- a/media/capture/video/android/capture_jni_registrar.h
+++ b/device/capture/video/android/capture_jni_registrar.h
@@ -2,18 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_ANDROID_CAPTURE_JNI_REGISTRAR_H_
-#define MEDIA_CAPTURE_VIDEO_ANDROID_CAPTURE_JNI_REGISTRAR_H_
+#ifndef DEVICE_CAPTURE_VIDEO_ANDROID_CAPTURE_JNI_REGISTRAR_H_
+#define DEVICE_CAPTURE_VIDEO_ANDROID_CAPTURE_JNI_REGISTRAR_H_
 
 #include <jni.h>
 
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 
-namespace media {
+namespace device {
 
 // Register all JNI bindings necessary for capture.
 CAPTURE_EXPORT bool RegisterCaptureJni(JNIEnv* env);
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_ANDROID_CAPTURE_JNI_REGISTRAR_H_
+#endif  // DEVICE_CAPTURE_VIDEO_ANDROID_CAPTURE_JNI_REGISTRAR_H_
diff --git a/media/capture/video/android/java/src/org/chromium/media/OWNERS b/device/capture/video/android/java/src/org/chromium/device/OWNERS
similarity index 100%
rename from media/capture/video/android/java/src/org/chromium/media/OWNERS
rename to device/capture/video/android/java/src/org/chromium/device/OWNERS
diff --git a/media/capture/video/android/java/src/org/chromium/media/PhotoCapabilities.java b/device/capture/video/android/java/src/org/chromium/device/PhotoCapabilities.java
similarity index 98%
rename from media/capture/video/android/java/src/org/chromium/media/PhotoCapabilities.java
rename to device/capture/video/android/java/src/org/chromium/device/PhotoCapabilities.java
index 3b7fcce..c41f657 100644
--- a/media/capture/video/android/java/src/org/chromium/media/PhotoCapabilities.java
+++ b/device/capture/video/android/java/src/org/chromium/device/PhotoCapabilities.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import org.chromium.base.annotations.CalledByNative;
 import org.chromium.base.annotations.JNINamespace;
@@ -10,7 +10,7 @@ import org.chromium.base.annotations.JNINamespace;
 /**
  * Set of PhotoCapabilities read from the different VideoCapture Devices.
  **/
-@JNINamespace("media")
+@JNINamespace("device")
 class PhotoCapabilities {
     public final int maxIso;
     public final int minIso;
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCapture.java b/device/capture/video/android/java/src/org/chromium/device/VideoCapture.java
similarity index 98%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCapture.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCapture.java
index 71a8bb1..3500596 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCapture.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCapture.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.content.Context;
 import android.graphics.ImageFormat;
@@ -19,7 +19,7 @@ import java.nio.ByteBuffer;
  * needs to use to configure, start capture, and to be reached by callbacks and
  * provides some neccesary data type(s) with accessors.
  **/
-@JNINamespace("media")
+@JNINamespace("device")
 public abstract class VideoCapture {
     // The angle (0, 90, 180, 270) that the image needs to be rotated to show in
     // the display's native orientation.
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureAndroid.java b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureAndroid.java
similarity index 99%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCaptureAndroid.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCaptureAndroid.java
index 1571a86..9296d6f 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureAndroid.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureAndroid.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.content.Context;
 import android.graphics.ImageFormat;
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera.java b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureCamera.java
similarity index 99%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCaptureCamera.java
index 5360786..e20f9fd 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureCamera.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.annotation.TargetApi;
 import android.content.Context;
@@ -22,7 +22,7 @@ import java.util.concurrent.locks.ReentrantLock;
  * for capture using android.hardware.Camera API (deprecated in API 21). Normal
  * Android and Tango devices are extensions of this class.
  **/
-@JNINamespace("media")
+@JNINamespace("device")
 @SuppressWarnings("deprecation")
 // TODO: is this class only used on ICS MR1 (or some later version) and above?
 @TargetApi(Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1)
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureCamera2.java
similarity index 99%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCaptureCamera2.java
index e4da6be..04badf3 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureCamera2.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureCamera2.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.annotation.TargetApi;
 import android.content.Context;
@@ -39,7 +39,7 @@ import java.util.List;
  * static methods are provided to retrieve information on current system cameras
  * and their capabilities, using android.hardware.camera2.CameraManager.
  **/
-@JNINamespace("media")
+@JNINamespace("device")
 @TargetApi(Build.VERSION_CODES.LOLLIPOP)
 public class VideoCaptureCamera2 extends VideoCapture {
     // Inner class to extend a CameraDevice state change listener.
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureFactory.java b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureFactory.java
similarity index 99%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCaptureFactory.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCaptureFactory.java
index c88f9f7..7f16911 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureFactory.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureFactory.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.Manifest;
 import android.content.Context;
@@ -22,7 +22,7 @@ import org.chromium.base.annotations.JNINamespace;
  * ChromiumCameraInfo is an internal class with some static methods needed from
  * the rest of the class to manipulate the |id|s of normal and special devices.
  **/
-@JNINamespace("media")
+@JNINamespace("device")
 @SuppressWarnings("deprecation")
 class VideoCaptureFactory {
     // Internal class to encapsulate camera device id manipulations.
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureFormat.java b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureFormat.java
similarity index 96%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCaptureFormat.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCaptureFormat.java
index a875843..b2c68e2 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureFormat.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureFormat.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 class VideoCaptureFormat {
     int mWidth;
diff --git a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureTango.java b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureTango.java
similarity index 99%
rename from media/capture/video/android/java/src/org/chromium/media/VideoCaptureTango.java
rename to device/capture/video/android/java/src/org/chromium/device/VideoCaptureTango.java
index d7732ce..6e63fdd 100644
--- a/media/capture/video/android/java/src/org/chromium/media/VideoCaptureTango.java
+++ b/device/capture/video/android/java/src/org/chromium/device/VideoCaptureTango.java
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-package org.chromium.media;
+package org.chromium.device;
 
 import android.content.Context;
 import android.graphics.ImageFormat;
diff --git a/media/capture/video/android/photo_capabilities.cc b/device/capture/video/android/photo_capabilities.cc
similarity index 96%
rename from media/capture/video/android/photo_capabilities.cc
rename to device/capture/video/android/photo_capabilities.cc
index 4dea525..9929726 100644
--- a/media/capture/video/android/photo_capabilities.cc
+++ b/device/capture/video/android/photo_capabilities.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/android/photo_capabilities.h"
+#include "device/capture/video/android/photo_capabilities.h"
 
 #include "base/android/jni_android.h"
 #include "base/android/jni_array.h"
@@ -11,7 +11,7 @@
 
 using base::android::AttachCurrentThread;
 
-namespace media {
+namespace device {
 
 PhotoCapabilities::PhotoCapabilities(
     base::android::ScopedJavaLocalRef<jobject> object)
@@ -95,4 +95,4 @@ bool PhotoCapabilities::getAutoFocusInUse() const {
                                                   object_.obj());
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/android/photo_capabilities.h b/device/capture/video/android/photo_capabilities.h
similarity index 78%
rename from media/capture/video/android/photo_capabilities.h
rename to device/capture/video/android/photo_capabilities.h
index de6d38f..7a79f8c 100644
--- a/media/capture/video/android/photo_capabilities.h
+++ b/device/capture/video/android/photo_capabilities.h
@@ -2,15 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_ANDROID_PHOTO_CAPABILITIES_H_
-#define MEDIA_CAPTURE_VIDEO_ANDROID_PHOTO_CAPABILITIES_H_
+#ifndef DEVICE_CAPTURE_VIDEO_ANDROID_PHOTO_CAPABILITIES_H_
+#define DEVICE_CAPTURE_VIDEO_ANDROID_PHOTO_CAPABILITIES_H_
 
 #include <jni.h>
 #include <string>
 
 #include "base/android/scoped_java_ref.h"
 
-namespace media {
+namespace device {
 
 class PhotoCapabilities {
  public:
@@ -35,6 +35,6 @@ class PhotoCapabilities {
   const base::android::ScopedJavaLocalRef<jobject> object_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_ANDROID_PHOTO_CAPABILITIES_H_
+#endif  // DEVICE_CAPTURE_VIDEO_ANDROID_PHOTO_CAPABILITIES_H_
diff --git a/media/capture/video/android/video_capture_device_android.cc b/device/capture/video/android/video_capture_device_android.cc
similarity index 93%
rename from media/capture/video/android/video_capture_device_android.cc
rename to device/capture/video/android/video_capture_device_android.cc
index 3d0774c..ab9d39d 100644
--- a/media/capture/video/android/video_capture_device_android.cc
+++ b/device/capture/video/android/video_capture_device_android.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/android/video_capture_device_android.h"
+#include "device/capture/video/android/video_capture_device_android.h"
 
 #include <stdint.h>
 #include <utility>
@@ -12,9 +12,9 @@
 #include "base/android/jni_string.h"
 #include "base/numerics/safe_conversions.h"
 #include "base/strings/string_number_conversions.h"
+#include "device/capture/video/android/photo_capabilities.h"
+#include "device/capture/video/android/video_capture_device_factory_android.h"
 #include "jni/VideoCapture_jni.h"
-#include "media/capture/video/android/photo_capabilities.h"
-#include "media/capture/video/android/video_capture_device_factory_android.h"
 #include "third_party/libyuv/include/libyuv.h"
 
 using base::android::AttachCurrentThread;
@@ -24,7 +24,7 @@ using base::android::MethodID;
 using base::android::JavaRef;
 using base::android::ScopedJavaLocalRef;
 
-namespace media {
+namespace device {
 
 // static
 bool VideoCaptureDeviceAndroid::RegisterVideoCaptureDevice(JNIEnv* env) {
@@ -167,33 +167,34 @@ void VideoCaptureDeviceAndroid::GetPhotoCapabilities(
       Java_VideoCapture_getPhotoCapabilities(env, j_capture_.obj()));
 
   // TODO(mcasas): Manual member copying sucks, consider adding typemapping from
-  // PhotoCapabilities to mojom::PhotoCapabilitiesPtr, https://crbug.com/622002.
-  mojom::PhotoCapabilitiesPtr photo_capabilities =
-      mojom::PhotoCapabilities::New();
-  photo_capabilities->iso = mojom::Range::New();
+  // PhotoCapabilities to media::mojom::PhotoCapabilitiesPtr,
+  // https://crbug.com/622002.
+  media::mojom::PhotoCapabilitiesPtr photo_capabilities =
+      media::mojom::PhotoCapabilities::New();
+  photo_capabilities->iso = media::mojom::Range::New();
   photo_capabilities->iso->current = caps.getCurrentIso();
   photo_capabilities->iso->max = caps.getMaxIso();
   photo_capabilities->iso->min = caps.getMinIso();
-  photo_capabilities->height = mojom::Range::New();
+  photo_capabilities->height = media::mojom::Range::New();
   photo_capabilities->height->current = caps.getCurrentHeight();
   photo_capabilities->height->max = caps.getMaxHeight();
   photo_capabilities->height->min = caps.getMinHeight();
-  photo_capabilities->width = mojom::Range::New();
+  photo_capabilities->width = media::mojom::Range::New();
   photo_capabilities->width->current = caps.getCurrentWidth();
   photo_capabilities->width->max = caps.getMaxWidth();
   photo_capabilities->width->min = caps.getMinWidth();
-  photo_capabilities->zoom = mojom::Range::New();
+  photo_capabilities->zoom = media::mojom::Range::New();
   photo_capabilities->zoom->current = caps.getCurrentZoom();
   photo_capabilities->zoom->max = caps.getMaxZoom();
   photo_capabilities->zoom->min = caps.getMinZoom();
   photo_capabilities->focus_mode = caps.getAutoFocusInUse()
-                                       ? mojom::FocusMode::AUTO
-                                       : mojom::FocusMode::MANUAL;
+                                       ? media::mojom::FocusMode::AUTO
+                                       : media::mojom::FocusMode::MANUAL;
   callback.Run(std::move(photo_capabilities));
 }
 
 void VideoCaptureDeviceAndroid::SetPhotoOptions(
-    mojom::PhotoSettingsPtr settings,
+    media::mojom::PhotoSettingsPtr settings,
     SetPhotoOptionsCallback callback) {
   DCHECK(thread_checker_.CalledOnValidThread());
   JNIEnv* env = AttachCurrentThread();
@@ -348,7 +349,7 @@ void VideoCaptureDeviceAndroid::OnPhotoTaken(
     return;
   }
 
-  mojom::BlobPtr blob = mojom::Blob::New();
+  media::mojom::BlobPtr blob = media::mojom::Blob::New();
   base::android::JavaByteArrayToByteVector(env, data.obj(), &blob->data);
   blob->mime_type = blob->data.empty() ? "" : "image/jpeg";
   cb->Run(std::move(blob));
@@ -385,4 +386,4 @@ void VideoCaptureDeviceAndroid::SetErrorState(
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/android/video_capture_device_android.h b/device/capture/video/android/video_capture_device_android.h
similarity index 86%
rename from media/capture/video/android/video_capture_device_android.h
rename to device/capture/video/android/video_capture_device_android.h
index 9a637a3..b2f4c8a 100644
--- a/media/capture/video/android/video_capture_device_android.h
+++ b/device/capture/video/android/video_capture_device_android.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_ANDROID_H_
-#define MEDIA_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_ANDROID_H_
+#ifndef DEVICE_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_ANDROID_H_
+#define DEVICE_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_ANDROID_H_
 
 #include <jni.h>
 #include <string>
@@ -14,14 +14,14 @@
 #include "base/threading/thread.h"
 #include "base/threading/thread_checker.h"
 #include "base/time/time.h"
-#include "media/capture/capture_export.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/video/video_capture_device.h"
 
 namespace tracked_objects {
 class Location;
 }  // namespace tracked_
 
-namespace media {
+namespace device {
 
 // VideoCaptureDevice on Android. The VideoCaptureDevice API's are called
 // by VideoCaptureManager on its own thread, while OnFrameAvailable is called
@@ -32,7 +32,7 @@ class CAPTURE_EXPORT VideoCaptureDeviceAndroid : public VideoCaptureDevice {
   // Automatically generated enum to interface with Java world.
   //
   // A Java counterpart will be generated for this enum.
-  // GENERATED_JAVA_ENUM_PACKAGE: org.chromium.media
+  // GENERATED_JAVA_ENUM_PACKAGE: org.chromium.device
   enum AndroidImageFormat {
     // Android graphics ImageFormat mapping, see reference in:
     // http://developer.android.com/reference/android/graphics/ImageFormat.html
@@ -60,18 +60,18 @@ class CAPTURE_EXPORT VideoCaptureDeviceAndroid : public VideoCaptureDevice {
                         std::unique_ptr<Client> client) override;
   void StopAndDeAllocate() override;
   void GetPhotoCapabilities(GetPhotoCapabilitiesCallback callback) override;
-  void SetPhotoOptions(mojom::PhotoSettingsPtr settings,
+  void SetPhotoOptions(media::mojom::PhotoSettingsPtr settings,
                        SetPhotoOptionsCallback callback) override;
   void TakePhoto(TakePhotoCallback callback) override;
 
-  // Implement org.chromium.media.VideoCapture.nativeOnFrameAvailable.
+  // Implement org.chromium.device.VideoCapture.nativeOnFrameAvailable.
   void OnFrameAvailable(JNIEnv* env,
                         const base::android::JavaParamRef<jobject>& obj,
                         const base::android::JavaParamRef<jbyteArray>& data,
                         jint length,
                         jint rotation);
 
-  // Implement org.chromium.media.VideoCapture.nativeOnI420FrameAvailable.
+  // Implement org.chromium.device.VideoCapture.nativeOnI420FrameAvailable.
   void OnI420FrameAvailable(JNIEnv* env,
                             jobject obj,
                             jobject y_buffer,
@@ -84,12 +84,12 @@ class CAPTURE_EXPORT VideoCaptureDeviceAndroid : public VideoCaptureDevice {
                             jint height,
                             jint rotation);
 
-  // Implement org.chromium.media.VideoCapture.nativeOnError.
+  // Implement org.chromium.device.VideoCapture.nativeOnError.
   void OnError(JNIEnv* env,
                const base::android::JavaParamRef<jobject>& obj,
                const base::android::JavaParamRef<jstring>& message);
 
-  // Implement org.chromium.media.VideoCapture.nativeOnPhotoTaken.
+  // Implement org.chromium.device.VideoCapture.nativeOnPhotoTaken.
   void OnPhotoTaken(JNIEnv* env,
                     const base::android::JavaParamRef<jobject>& obj,
                     jlong callback_id,
@@ -134,6 +134,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceAndroid : public VideoCaptureDevice {
   DISALLOW_IMPLICIT_CONSTRUCTORS(VideoCaptureDeviceAndroid);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_ANDROID_H_
+#endif  // DEVICE_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_ANDROID_H_
diff --git a/media/capture/video/android/video_capture_device_factory_android.cc b/device/capture/video/android/video_capture_device_factory_android.cc
similarity index 87%
rename from media/capture/video/android/video_capture_device_factory_android.cc
rename to device/capture/video/android/video_capture_device_factory_android.cc
index 3a65bda..6bbc026 100644
--- a/media/capture/video/android/video_capture_device_factory_android.cc
+++ b/device/capture/video/android/video_capture_device_factory_android.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/android/video_capture_device_factory_android.h"
+#include "device/capture/video/android/video_capture_device_factory_android.h"
 
 #include <utility>
 
@@ -10,13 +10,13 @@
 #include "base/android/jni_string.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/strings/stringprintf.h"
+#include "device/capture/video/android/video_capture_device_android.h"
 #include "jni/VideoCaptureFactory_jni.h"
-#include "media/capture/video/android/video_capture_device_android.h"
 
 using base::android::AttachCurrentThread;
 using base::android::ScopedJavaLocalRef;
 
-namespace media {
+namespace device {
 
 // static
 ScopedJavaLocalRef<jobject>
@@ -105,7 +105,7 @@ void VideoCaptureDeviceFactoryAndroid::GetSupportedFormats(
 
     VideoPixelFormat pixel_format =
         media::PIXEL_FORMAT_UNKNOWN;
-    switch (media::Java_VideoCaptureFactory_getCaptureFormatPixelFormat(
+    switch (Java_VideoCaptureFactory_getCaptureFormatPixelFormat(
         env, format.obj())) {
       case VideoCaptureDeviceAndroid::ANDROID_IMAGE_FORMAT_YV12:
         pixel_format = media::PIXEL_FORMAT_YV12;
@@ -117,12 +117,10 @@ void VideoCaptureDeviceFactoryAndroid::GetSupportedFormats(
         continue;
     }
     VideoCaptureFormat capture_format(
-        gfx::Size(media::Java_VideoCaptureFactory_getCaptureFormatWidth(
-                      env, format.obj()),
-                  media::Java_VideoCaptureFactory_getCaptureFormatHeight(
-                      env, format.obj())),
-        media::Java_VideoCaptureFactory_getCaptureFormatFramerate(env,
-                                                                  format.obj()),
+        gfx::Size(
+            Java_VideoCaptureFactory_getCaptureFormatWidth(env, format.obj()),
+            Java_VideoCaptureFactory_getCaptureFormatHeight(env, format.obj())),
+        Java_VideoCaptureFactory_getCaptureFormatFramerate(env, format.obj()),
         pixel_format);
     capture_formats->push_back(capture_format);
     DVLOG(1) << device.display_name << " "
@@ -137,4 +135,4 @@ VideoCaptureDeviceFactory::CreateVideoCaptureDeviceFactory(
   return new VideoCaptureDeviceFactoryAndroid();
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/android/video_capture_device_factory_android.h b/device/capture/video/android/video_capture_device_factory_android.h
similarity index 74%
rename from media/capture/video/android/video_capture_device_factory_android.h
rename to device/capture/video/android/video_capture_device_factory_android.h
index 400b8b4..cc450ea 100644
--- a/media/capture/video/android/video_capture_device_factory_android.h
+++ b/device/capture/video/android/video_capture_device_factory_android.h
@@ -2,18 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_FACTORY_ANDROID_H_
-#define MEDIA_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_FACTORY_ANDROID_H_
+#ifndef DEVICE_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_FACTORY_ANDROID_H_
+#define DEVICE_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_FACTORY_ANDROID_H_
 
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
 #include <jni.h>
 
 #include "base/android/scoped_java_ref.h"
 #include "base/macros.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
-namespace media {
+namespace device {
 
 // VideoCaptureDeviceFactory on Android. This class implements the static
 // VideoCapture methods and the factory of VideoCaptureAndroid.
@@ -37,6 +37,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceFactoryAndroid
  private:
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceFactoryAndroid);
 };
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_FACTORY_ANDROID_H_
+#endif  // DEVICE_CAPTURE_VIDEO_ANDROID_VIDEO_CAPTURE_DEVICE_FACTORY_ANDROID_H_
diff --git a/media/capture/video/fake_video_capture_device.cc b/device/capture/video/fake_video_capture_device.cc
similarity index 87%
rename from media/capture/video/fake_video_capture_device.cc
rename to device/capture/video/fake_video_capture_device.cc
index 698588f..e60a9df 100644
--- a/media/capture/video/fake_video_capture_device.cc
+++ b/device/capture/video/fake_video_capture_device.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/fake_video_capture_device.h"
+#include "device/capture/video/fake_video_capture_device.h"
 
 #include <stddef.h>
 #include <algorithm>
@@ -22,7 +22,7 @@
 #include "third_party/skia/include/core/SkPaint.h"
 #include "ui/gfx/codec/png_codec.h"
 
-namespace media {
+namespace device {
 
 // Sweep at 600 deg/sec.
 static const float kPacmanAngularVelocity = 600;
@@ -96,12 +96,12 @@ void DoTakeFakePhoto(VideoCaptureDevice::TakePhotoCallback callback,
                      float fake_capture_rate,
                      uint32_t zoom) {
   std::unique_ptr<uint8_t[]> buffer(new uint8_t[VideoFrame::AllocationSize(
-      PIXEL_FORMAT_ARGB, capture_format.frame_size)]);
+      media::PIXEL_FORMAT_ARGB, capture_format.frame_size)]);
 
   DrawPacman(true /* use_argb */, buffer.get(), elapsed_time, fake_capture_rate,
              capture_format.frame_size, zoom);
 
-  mojom::BlobPtr blob = mojom::Blob::New();
+  media::mojom::BlobPtr blob = media::mojom::Blob::New();
   const bool result = gfx::PNGCodec::Encode(
       buffer.get(), gfx::PNGCodec::FORMAT_RGBA, capture_format.frame_size,
       capture_format.frame_size.width() * 4, true /* discard_transparency */,
@@ -144,18 +144,18 @@ void FakeVideoCaptureDevice::AllocateAndStart(
     capture_format_.frame_size.SetSize(320, 240);
 
   if (buffer_ownership_ == BufferOwnership::CLIENT_BUFFERS) {
-    capture_format_.pixel_storage = PIXEL_STORAGE_CPU;
-    capture_format_.pixel_format = PIXEL_FORMAT_ARGB;
+    capture_format_.pixel_storage = media::PIXEL_STORAGE_CPU;
+    capture_format_.pixel_format = media::PIXEL_FORMAT_ARGB;
     DVLOG(1) << "starting with client argb buffers";
   } else if (buffer_ownership_ == BufferOwnership::OWN_BUFFERS) {
-    capture_format_.pixel_storage = PIXEL_STORAGE_CPU;
-    capture_format_.pixel_format = PIXEL_FORMAT_I420;
+    capture_format_.pixel_storage = media::PIXEL_STORAGE_CPU;
+    capture_format_.pixel_format = media::PIXEL_FORMAT_I420;
     DVLOG(1) << "starting with own I420 buffers";
   }
 
-  if (capture_format_.pixel_format == PIXEL_FORMAT_I420) {
+  if (capture_format_.pixel_format == media::PIXEL_FORMAT_I420) {
     fake_frame_.reset(new uint8_t[VideoFrame::AllocationSize(
-        PIXEL_FORMAT_I420, capture_format_.frame_size)]);
+        media::PIXEL_FORMAT_I420, capture_format_.frame_size)]);
   }
 
   beep_time_ = base::TimeDelta();
@@ -180,31 +180,32 @@ void FakeVideoCaptureDevice::StopAndDeAllocate() {
 
 void FakeVideoCaptureDevice::GetPhotoCapabilities(
     GetPhotoCapabilitiesCallback callback) {
-  mojom::PhotoCapabilitiesPtr photo_capabilities =
-      mojom::PhotoCapabilities::New();
-  photo_capabilities->iso = mojom::Range::New();
+  media::mojom::PhotoCapabilitiesPtr photo_capabilities =
+      media::mojom::PhotoCapabilities::New();
+  photo_capabilities->iso = media::mojom::Range::New();
   photo_capabilities->iso->current = 100;
   photo_capabilities->iso->max = 100;
   photo_capabilities->iso->min = 100;
-  photo_capabilities->height = mojom::Range::New();
+  photo_capabilities->height = media::mojom::Range::New();
   photo_capabilities->height->current = capture_format_.frame_size.height();
   photo_capabilities->height->max = 1080;
   photo_capabilities->height->min = 240;
-  photo_capabilities->width = mojom::Range::New();
+  photo_capabilities->width = media::mojom::Range::New();
   photo_capabilities->width->current = capture_format_.frame_size.width();
   photo_capabilities->width->max = 1920;
   photo_capabilities->width->min = 320;
-  photo_capabilities->focus_mode = mojom::FocusMode::UNAVAILABLE;
-  photo_capabilities->zoom = mojom::Range::New();
+  photo_capabilities->focus_mode = media::mojom::FocusMode::UNAVAILABLE;
+  photo_capabilities->zoom = media::mojom::Range::New();
   photo_capabilities->zoom->current = current_zoom_;
   photo_capabilities->zoom->max = kMaxZoom;
   photo_capabilities->zoom->min = kMinZoom;
-  photo_capabilities->focus_mode = mojom::FocusMode::UNAVAILABLE;
+  photo_capabilities->focus_mode = media::mojom::FocusMode::UNAVAILABLE;
   callback.Run(std::move(photo_capabilities));
 }
 
-void FakeVideoCaptureDevice::SetPhotoOptions(mojom::PhotoSettingsPtr settings,
-                                             SetPhotoOptionsCallback callback) {
+void FakeVideoCaptureDevice::SetPhotoOptions(
+    media::mojom::PhotoSettingsPtr settings,
+    SetPhotoOptionsCallback callback) {
   if (settings->has_zoom)
     current_zoom_ = std::max(kMinZoom, std::min(settings->zoom, kMaxZoom));
   callback.Run(true);
@@ -250,7 +251,7 @@ void FakeVideoCaptureDevice::CaptureUsingClientBuffers(
   DLOG_IF(ERROR, !capture_buffer) << "Couldn't allocate Capture Buffer";
   DCHECK(capture_buffer->data()) << "Buffer has NO backing memory";
 
-  if (capture_format_.pixel_storage == PIXEL_STORAGE_GPUMEMORYBUFFER &&
+  if (capture_format_.pixel_storage == media::PIXEL_STORAGE_GPUMEMORYBUFFER &&
       capture_format_.pixel_format == media::PIXEL_FORMAT_I420) {
     // Since SkBitmap expects a packed&continuous memory region for I420, we
     // need to use |fake_frame_| to draw onto.
@@ -260,17 +261,18 @@ void FakeVideoCaptureDevice::CaptureUsingClientBuffers(
 
     // Copy data from |fake_frame_| into the reserved planes of GpuMemoryBuffer.
     size_t offset = 0;
-    for (size_t i = 0; i < VideoFrame::NumPlanes(PIXEL_FORMAT_I420); ++i) {
+    for (size_t i = 0; i < VideoFrame::NumPlanes(media::PIXEL_FORMAT_I420);
+         ++i) {
       const size_t plane_size =
-          VideoFrame::PlaneSize(PIXEL_FORMAT_I420, i,
+          VideoFrame::PlaneSize(media::PIXEL_FORMAT_I420, i,
                                 capture_format_.frame_size)
               .GetArea();
       memcpy(capture_buffer->data(i), fake_frame_.get() + offset, plane_size);
       offset += plane_size;
     }
   } else {
-    DCHECK_EQ(capture_format_.pixel_storage, PIXEL_STORAGE_CPU);
-    DCHECK_EQ(capture_format_.pixel_format, PIXEL_FORMAT_ARGB);
+    DCHECK_EQ(capture_format_.pixel_storage, media::PIXEL_STORAGE_CPU);
+    DCHECK_EQ(capture_format_.pixel_format, media::PIXEL_FORMAT_ARGB);
     uint8_t* data_ptr = static_cast<uint8_t*>(capture_buffer->data());
     memset(data_ptr, 0, capture_buffer->mapped_size());
     DrawPacman(true /* use_argb */, data_ptr, elapsed_time_, fake_capture_rate_,
@@ -302,7 +304,7 @@ void FakeVideoCaptureDevice::BeepAndScheduleNextCapture(
 
   // Generate a synchronized beep twice per second.
   if (beep_time_ >= beep_interval) {
-    FakeAudioInputStream::BeepOnce();
+    media::FakeAudioInputStream::BeepOnce();
     beep_time_ -= beep_interval;
   }
 
@@ -317,4 +319,4 @@ void FakeVideoCaptureDevice::BeepAndScheduleNextCapture(
       FROM_HERE, base::Bind(next_capture, next_execution_time), delay);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/fake_video_capture_device.h b/device/capture/video/fake_video_capture_device.h
similarity index 88%
rename from media/capture/video/fake_video_capture_device.h
rename to device/capture/video/fake_video_capture_device.h
index 9e7cb41..00e27c4 100644
--- a/media/capture/video/fake_video_capture_device.h
+++ b/device/capture/video/fake_video_capture_device.h
@@ -5,8 +5,8 @@
 // Implementation of a fake VideoCaptureDevice class. Used for testing other
 // video capture classes when no real hardware is available.
 
-#ifndef MEDIA_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_H_
-#define MEDIA_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_H_
+#ifndef DEVICE_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_H_
+#define DEVICE_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_H_
 
 #include <stdint.h>
 
@@ -18,9 +18,9 @@
 #include "base/memory/weak_ptr.h"
 #include "base/threading/thread_checker.h"
 #include "base/time/time.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
-namespace media {
+namespace device {
 
 class CAPTURE_EXPORT FakeVideoCaptureDevice : public VideoCaptureDevice {
  public:
@@ -38,7 +38,7 @@ class CAPTURE_EXPORT FakeVideoCaptureDevice : public VideoCaptureDevice {
                         std::unique_ptr<Client> client) override;
   void StopAndDeAllocate() override;
   void GetPhotoCapabilities(GetPhotoCapabilitiesCallback callback) override;
-  void SetPhotoOptions(mojom::PhotoSettingsPtr settings,
+  void SetPhotoOptions(media::mojom::PhotoSettingsPtr settings,
                        SetPhotoOptionsCallback callback) override;
   void TakePhoto(TakePhotoCallback callback) override;
 
@@ -77,6 +77,6 @@ class CAPTURE_EXPORT FakeVideoCaptureDevice : public VideoCaptureDevice {
   DISALLOW_COPY_AND_ASSIGN(FakeVideoCaptureDevice);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_H_
+#endif  // DEVICE_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_H_
diff --git a/media/capture/video/fake_video_capture_device_factory.cc b/device/capture/video/fake_video_capture_device_factory.cc
similarity index 97%
rename from media/capture/video/fake_video_capture_device_factory.cc
rename to device/capture/video/fake_video_capture_device_factory.cc
index 38ef605..b0536cf 100644
--- a/media/capture/video/fake_video_capture_device_factory.cc
+++ b/device/capture/video/fake_video_capture_device_factory.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/fake_video_capture_device_factory.h"
+#include "device/capture/video/fake_video_capture_device_factory.h"
 
 #include "base/command_line.h"
 #include "base/strings/string_number_conversions.h"
@@ -13,7 +13,7 @@
 #include "build/build_config.h"
 #include "media/base/media_switches.h"
 
-namespace media {
+namespace device {
 
 // Cap the frame rate command line input to reasonable values.
 static const float kFakeCaptureMinFrameRate = 5.0f;
@@ -113,4 +113,4 @@ void FakeVideoCaptureDeviceFactory::parse_command_line() {
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/fake_video_capture_device_factory.h b/device/capture/video/fake_video_capture_device_factory.h
similarity index 78%
rename from media/capture/video/fake_video_capture_device_factory.h
rename to device/capture/video/fake_video_capture_device_factory.h
index 9951eb8..964848d 100644
--- a/media/capture/video/fake_video_capture_device_factory.h
+++ b/device/capture/video/fake_video_capture_device_factory.h
@@ -4,13 +4,13 @@
 
 // Implementation of a fake VideoCaptureDeviceFactory class.
 
-#ifndef MEDIA_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
-#define MEDIA_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#ifndef DEVICE_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#define DEVICE_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
 
-#include "media/capture/video/fake_video_capture_device.h"
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/fake_video_capture_device.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
-namespace media {
+namespace device {
 
 // Extension of VideoCaptureDeviceFactory to create and manipulate fake devices,
 // not including file-based ones.
@@ -45,6 +45,6 @@ class CAPTURE_EXPORT FakeVideoCaptureDeviceFactory
   float frame_rate_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#endif  // DEVICE_CAPTURE_VIDEO_FAKE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
diff --git a/media/capture/video/fake_video_capture_device_unittest.cc b/device/capture/video/fake_video_capture_device_unittest.cc
similarity index 92%
rename from media/capture/video/fake_video_capture_device_unittest.cc
rename to device/capture/video/fake_video_capture_device_unittest.cc
index 6cf58e1..d80566d 100644
--- a/media/capture/video/fake_video_capture_device_unittest.cc
+++ b/device/capture/video/fake_video_capture_device_unittest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/fake_video_capture_device.h"
+#include "device/capture/video/fake_video_capture_device.h"
 
 #include <stddef.h>
 #include <stdint.h>
@@ -17,10 +17,10 @@
 #include "base/test/test_timeouts.h"
 #include "base/threading/thread.h"
 #include "build/build_config.h"
+#include "device/capture/video/fake_video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/base/media_switches.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/fake_video_capture_device_factory.h"
-#include "media/capture/video/video_capture_device.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
@@ -30,7 +30,7 @@ using ::testing::Combine;
 using ::testing::SaveArg;
 using ::testing::Values;
 
-namespace media {
+namespace device {
 
 namespace {
 
@@ -102,7 +102,7 @@ class MockClient : public VideoCaptureDevice::Client {
       std::unique_ptr<Buffer> buffer,
       const scoped_refptr<media::VideoFrame>& frame) {
     VideoCaptureFormat format(frame->natural_size(), 30.0,
-                              PIXEL_FORMAT_I420);
+                              media::PIXEL_FORMAT_I420);
     frame_cb_.Run(format);
   }
   std::unique_ptr<Buffer> ResurrectLastOutputBuffer(
@@ -136,22 +136,26 @@ class DeviceEnumerationListener
 class ImageCaptureClient : public base::RefCounted<ImageCaptureClient> {
  public:
   // GMock doesn't support move-only arguments, so we use this forward method.
-  void DoOnGetPhotoCapabilities(mojom::PhotoCapabilitiesPtr capabilities) {
+  void DoOnGetPhotoCapabilities(
+      media::mojom::PhotoCapabilitiesPtr capabilities) {
     capabilities_ = std::move(capabilities);
     OnCorrectGetPhotoCapabilities();
   }
   MOCK_METHOD0(OnCorrectGetPhotoCapabilities, void(void));
-  MOCK_METHOD1(OnGetPhotoCapabilitiesFailure,
-               void(const base::Callback<void(mojom::PhotoCapabilitiesPtr)>&));
+  MOCK_METHOD1(
+      OnGetPhotoCapabilitiesFailure,
+      void(const base::Callback<void(media::mojom::PhotoCapabilitiesPtr)>&));
 
-  const mojom::PhotoCapabilities* capabilities() { return capabilities_.get(); }
+  const media::mojom::PhotoCapabilities* capabilities() {
+    return capabilities_.get();
+  }
 
   MOCK_METHOD1(OnCorrectSetPhotoOptions, void(bool));
   MOCK_METHOD1(OnSetPhotoOptionsFailure,
                void(const base::Callback<void(bool)>&));
 
   // GMock doesn't support move-only arguments, so we use this forward method.
-  void DoOnPhotoTaken(mojom::BlobPtr blob) {
+  void DoOnPhotoTaken(media::mojom::BlobPtr blob) {
     // Only PNG images are supported right now.
     EXPECT_STREQ("image/png", blob->mime_type.c_str());
     // Not worth decoding the incoming data. Just check that the header is PNG.
@@ -164,13 +168,13 @@ class ImageCaptureClient : public base::RefCounted<ImageCaptureClient> {
   }
   MOCK_METHOD0(OnCorrectPhotoTaken, void(void));
   MOCK_METHOD1(OnTakePhotoFailure,
-               void(const base::Callback<void(mojom::BlobPtr)>&));
+               void(const base::Callback<void(media::mojom::BlobPtr)>&));
 
  private:
   friend class base::RefCounted<ImageCaptureClient>;
   virtual ~ImageCaptureClient() {}
 
-  mojom::PhotoCapabilitiesPtr capabilities_;
+  media::mojom::PhotoCapabilitiesPtr capabilities_;
 };
 
 }  // namespace
@@ -279,19 +283,19 @@ TEST_F(FakeVideoCaptureDeviceTest, GetDeviceSupportedFormats) {
     ASSERT_EQ(supported_formats.size(), 4u);
     EXPECT_EQ(supported_formats[0].frame_size.width(), 320);
     EXPECT_EQ(supported_formats[0].frame_size.height(), 240);
-    EXPECT_EQ(supported_formats[0].pixel_format, PIXEL_FORMAT_I420);
+    EXPECT_EQ(supported_formats[0].pixel_format, media::PIXEL_FORMAT_I420);
     EXPECT_GE(supported_formats[0].frame_rate, 20.0);
     EXPECT_EQ(supported_formats[1].frame_size.width(), 640);
     EXPECT_EQ(supported_formats[1].frame_size.height(), 480);
-    EXPECT_EQ(supported_formats[1].pixel_format, PIXEL_FORMAT_I420);
+    EXPECT_EQ(supported_formats[1].pixel_format, media::PIXEL_FORMAT_I420);
     EXPECT_GE(supported_formats[1].frame_rate, 20.0);
     EXPECT_EQ(supported_formats[2].frame_size.width(), 1280);
     EXPECT_EQ(supported_formats[2].frame_size.height(), 720);
-    EXPECT_EQ(supported_formats[2].pixel_format, PIXEL_FORMAT_I420);
+    EXPECT_EQ(supported_formats[2].pixel_format, media::PIXEL_FORMAT_I420);
     EXPECT_GE(supported_formats[2].frame_rate, 20.0);
     EXPECT_EQ(supported_formats[3].frame_size.width(), 1920);
     EXPECT_EQ(supported_formats[3].frame_size.height(), 1080);
-    EXPECT_EQ(supported_formats[3].pixel_format, PIXEL_FORMAT_I420);
+    EXPECT_EQ(supported_formats[3].pixel_format, media::PIXEL_FORMAT_I420);
     EXPECT_GE(supported_formats[3].frame_rate, 20.0);
   }
 }
@@ -335,7 +339,7 @@ TEST_F(FakeVideoCaptureDeviceTest, GetAndSetCapabilities) {
   EXPECT_EQ(400u, capabilities->zoom->max);
   EXPECT_GE(capabilities->zoom->current, capabilities->zoom->min);
   EXPECT_GE(capabilities->zoom->max, capabilities->zoom->current);
-  EXPECT_EQ(mojom::FocusMode::UNAVAILABLE, capabilities->focus_mode);
+  EXPECT_EQ(media::mojom::FocusMode::UNAVAILABLE, capabilities->focus_mode);
 
   // Set options: zoom to the maximum value.
   const unsigned int max_zoom_value = capabilities->zoom->max;
@@ -345,7 +349,7 @@ TEST_F(FakeVideoCaptureDeviceTest, GetAndSetCapabilities) {
       base::Bind(&ImageCaptureClient::OnSetPhotoOptionsFailure,
                  image_capture_client_));
 
-  mojom::PhotoSettingsPtr settings = mojom::PhotoSettings::New();
+  media::mojom::PhotoSettingsPtr settings = media::mojom::PhotoSettings::New();
   settings->zoom = max_zoom_value;
   settings->has_zoom = true;
 
@@ -427,4 +431,4 @@ INSTANTIATE_TEST_CASE_P(,
                                CommandLineTestData{"fps=29.97", 29.97f},
                                CommandLineTestData{"fps=60", 60},
                                CommandLineTestData{"fps=1000", 60}));
-};  // namespace media
+};  // namespace device
diff --git a/media/capture/video/file_video_capture_device.cc b/device/capture/video/file_video_capture_device.cc
similarity index 97%
rename from media/capture/video/file_video_capture_device.cc
rename to device/capture/video/file_video_capture_device.cc
index 10b3710..7aa594c6 100644
--- a/media/capture/video/file_video_capture_device.cc
+++ b/device/capture/video/file_video_capture_device.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/file_video_capture_device.h"
+#include "device/capture/video/file_video_capture_device.h"
 
 #include <stddef.h>
 #include <utility>
@@ -17,7 +17,7 @@
 #include "media/base/video_capture_types.h"
 #include "media/filters/jpeg_parser.h"
 
-namespace media {
+namespace device {
 
 static const int kY4MHeaderMaxSize = 200;
 static const char kY4MSimpleFrameDelimiter[] = "FRAME";
@@ -226,8 +226,9 @@ bool MjpegFileParser::Initialize(media::VideoCaptureFormat* capture_format) {
     return false;
   }
 
-  JpegParseResult result;
-  if (!ParseJpegStream(mapped_file_->data(), mapped_file_->length(), &result))
+  media::JpegParseResult result;
+  if (!media::ParseJpegStream(mapped_file_->data(), mapped_file_->length(),
+                              &result))
     return false;
 
   frame_size_ = result.image_size;
@@ -250,9 +251,9 @@ bool MjpegFileParser::Initialize(media::VideoCaptureFormat* capture_format) {
 const uint8_t* MjpegFileParser::GetNextFrame(int* frame_size) {
   const uint8_t* buf_ptr = mapped_file_->data() + current_byte_index_;
 
-  JpegParseResult result;
-  if (!ParseJpegStream(buf_ptr, mapped_file_->length() - current_byte_index_,
-                       &result)) {
+  media::JpegParseResult result;
+  if (!media::ParseJpegStream(
+          buf_ptr, mapped_file_->length() - current_byte_index_, &result)) {
     return nullptr;
   }
   *frame_size = frame_size_ = result.image_size;
@@ -391,4 +392,4 @@ void FileVideoCaptureDevice::OnCaptureTask() {
       next_frame_time_ - current_time);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/file_video_capture_device.h b/device/capture/video/file_video_capture_device.h
similarity index 92%
rename from media/capture/video/file_video_capture_device.h
rename to device/capture/video/file_video_capture_device.h
index 53d2670..830ca4a 100644
--- a/media/capture/video/file_video_capture_device.h
+++ b/device/capture/video/file_video_capture_device.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_H_
-#define MEDIA_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_H_
+#ifndef DEVICE_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_H_
+#define DEVICE_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_H_
 
 #include <stdint.h>
 
@@ -15,9 +15,9 @@
 #include "base/macros.h"
 #include "base/threading/thread.h"
 #include "base/threading/thread_checker.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
-namespace media {
+namespace device {
 
 class VideoFileParser;
 
@@ -87,6 +87,6 @@ class CAPTURE_EXPORT FileVideoCaptureDevice : public VideoCaptureDevice {
   DISALLOW_COPY_AND_ASSIGN(FileVideoCaptureDevice);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_H_
+#endif  // DEVICE_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_H_
diff --git a/media/capture/video/file_video_capture_device_factory.cc b/device/capture/video/file_video_capture_device_factory.cc
similarity index 93%
rename from media/capture/video/file_video_capture_device_factory.cc
rename to device/capture/video/file_video_capture_device_factory.cc
index 0ead703..87be8bd 100644
--- a/media/capture/video/file_video_capture_device_factory.cc
+++ b/device/capture/video/file_video_capture_device_factory.cc
@@ -2,16 +2,16 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/file_video_capture_device_factory.h"
+#include "device/capture/video/file_video_capture_device_factory.h"
 
 #include "base/command_line.h"
 #include "base/files/file_path.h"
 #include "base/strings/sys_string_conversions.h"
 #include "build/build_config.h"
+#include "device/capture/video/file_video_capture_device.h"
 #include "media/base/media_switches.h"
-#include "media/capture/video/file_video_capture_device.h"
 
-namespace media {
+namespace device {
 
 const char kFileVideoCaptureDeviceName[] =
     "/dev/placeholder-for-file-backed-fake-capture-device";
@@ -73,4 +73,4 @@ void FileVideoCaptureDeviceFactory::GetSupportedFormats(
   supported_formats->push_back(capture_format);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/file_video_capture_device_factory.h b/device/capture/video/file_video_capture_device_factory.h
similarity index 77%
rename from media/capture/video/file_video_capture_device_factory.h
rename to device/capture/video/file_video_capture_device_factory.h
index 8dfd306..4268472 100644
--- a/media/capture/video/file_video_capture_device_factory.h
+++ b/device/capture/video/file_video_capture_device_factory.h
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
-#define MEDIA_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#ifndef DEVICE_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#define DEVICE_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
 
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
-namespace media {
+namespace device {
 
 // Extension of VideoCaptureDeviceFactory to create and manipulate file-backed
 // fake devices. These devices play back video-only files as video capture
@@ -30,6 +30,6 @@ class CAPTURE_EXPORT FileVideoCaptureDeviceFactory
       VideoCaptureFormats* supported_formats) override;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#endif  // DEVICE_CAPTURE_VIDEO_FILE_VIDEO_CAPTURE_DEVICE_FACTORY_H_
diff --git a/media/capture/video/linux/OWNERS b/device/capture/video/linux/OWNERS
similarity index 100%
rename from media/capture/video/linux/OWNERS
rename to device/capture/video/linux/OWNERS
diff --git a/media/capture/video/linux/v4l2_capture_delegate.cc b/device/capture/video/linux/v4l2_capture_delegate.cc
similarity index 95%
rename from media/capture/video/linux/v4l2_capture_delegate.cc
rename to device/capture/video/linux/v4l2_capture_delegate.cc
index a6f47b5..1ecae47 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.cc
+++ b/device/capture/video/linux/v4l2_capture_delegate.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/linux/v4l2_capture_delegate.h"
+#include "device/capture/video/linux/v4l2_capture_delegate.h"
 
 #include <poll.h>
 #include <sys/fcntl.h>
@@ -15,10 +15,10 @@
 #include "base/posix/eintr_wrapper.h"
 #include "base/strings/stringprintf.h"
 #include "build/build_config.h"
+#include "device/capture/video/linux/video_capture_device_linux.h"
 #include "media/base/bind_to_current_loop.h"
-#include "media/capture/video/linux/video_capture_device_linux.h"
 
-namespace media {
+namespace device {
 
 // Desired number of video buffers to allocate. The actual number of allocated
 // buffers by v4l2 driver can be higher or lower than this number.
@@ -44,19 +44,19 @@ static struct {
   VideoPixelFormat pixel_format;
   size_t num_planes;
 } const kSupportedFormatsAndPlanarity[] = {
-    {V4L2_PIX_FMT_YUV420, PIXEL_FORMAT_I420, 1},
-    {V4L2_PIX_FMT_YUYV, PIXEL_FORMAT_YUY2, 1},
-    {V4L2_PIX_FMT_UYVY, PIXEL_FORMAT_UYVY, 1},
-    {V4L2_PIX_FMT_RGB24, PIXEL_FORMAT_RGB24, 1},
+    {V4L2_PIX_FMT_YUV420, media::PIXEL_FORMAT_I420, 1},
+    {V4L2_PIX_FMT_YUYV, media::PIXEL_FORMAT_YUY2, 1},
+    {V4L2_PIX_FMT_UYVY, media::PIXEL_FORMAT_UYVY, 1},
+    {V4L2_PIX_FMT_RGB24, media::PIXEL_FORMAT_RGB24, 1},
     // MJPEG is usually sitting fairly low since we don't want to have to
     // decode. However, it is needed for large resolutions due to USB bandwidth
     // limitations, so GetListOfUsableFourCcs() can duplicate it on top, see
     // that method.
-    {V4L2_PIX_FMT_MJPEG, PIXEL_FORMAT_MJPEG, 1},
+    {V4L2_PIX_FMT_MJPEG, media::PIXEL_FORMAT_MJPEG, 1},
     // JPEG works as MJPEG on some gspca webcams from field reports, see
     // https://code.google.com/p/webrtc/issues/detail?id=529, put it as the
     // least preferred format.
-    {V4L2_PIX_FMT_JPEG, PIXEL_FORMAT_MJPEG, 1},
+    {V4L2_PIX_FMT_JPEG, media::PIXEL_FORMAT_MJPEG, 1},
 };
 
 // Fill in |format| with the given parameters.
@@ -136,10 +136,10 @@ VideoPixelFormat V4L2CaptureDelegate::V4l2FourCcToChromiumPixelFormat(
       return fourcc_and_pixel_format.pixel_format;
   }
   // Not finding a pixel format is OK during device capabilities enumeration.
-  // Let the caller decide if PIXEL_FORMAT_UNKNOWN is an error or
+  // Let the caller decide if media::PIXEL_FORMAT_UNKNOWN is an error or
   // not.
   DVLOG(1) << "Unsupported pixel format: " << FourccToString(v4l2_fourcc);
-  return PIXEL_FORMAT_UNKNOWN;
+  return media::PIXEL_FORMAT_UNKNOWN;
 }
 
 // static
@@ -219,7 +219,7 @@ void V4L2CaptureDelegate::AllocateAndStart(
   }
   const VideoPixelFormat pixel_format =
       V4l2FourCcToChromiumPixelFormat(video_fmt_.fmt.pix.pixelformat);
-  if (pixel_format == PIXEL_FORMAT_UNKNOWN) {
+  if (pixel_format == media::PIXEL_FORMAT_UNKNOWN) {
     SetErrorState(FROM_HERE, "Unsupported pixel format");
     return;
   }
@@ -444,4 +444,4 @@ bool V4L2CaptureDelegate::BufferTracker::Init(int fd,
   return true;
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/linux/v4l2_capture_delegate.h b/device/capture/video/linux/v4l2_capture_delegate.h
similarity index 88%
rename from media/capture/video/linux/v4l2_capture_delegate.h
rename to device/capture/video/linux/v4l2_capture_delegate.h
index 12027274..2fcd743 100644
--- a/media/capture/video/linux/v4l2_capture_delegate.h
+++ b/device/capture/video/linux/v4l2_capture_delegate.h
@@ -2,8 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_H_
-#define MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_H_
+#ifndef DEVICE_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_H_
+#define DEVICE_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_H_
 
 #include <stddef.h>
 #include <stdint.h>
@@ -12,7 +12,7 @@
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "build/build_config.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
 #if defined(OS_OPENBSD)
 #include <sys/videoio.h>
@@ -24,7 +24,7 @@ namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
+namespace device {
 
 // Class doing the actual Linux capture using V4L2 API. V4L2 SPLANE/MPLANE
 // capture specifics are implemented in derived classes. Created and destroyed
@@ -35,7 +35,8 @@ class V4L2CaptureDelegate final
  public:
   // Retrieves the #planes for a given |fourcc|, or 0 if unknown.
   static size_t GetNumPlanesForFourCc(uint32_t fourcc);
-  // Returns the Chrome pixel format for |v4l2_fourcc| or PIXEL_FORMAT_UNKNOWN.
+  // Returns the Chrome pixel format for |v4l2_fourcc| or
+  // media::PIXEL_FORMAT_UNKNOWN.
   static VideoPixelFormat V4l2FourCcToChromiumPixelFormat(
       uint32_t v4l2_fourcc);
 
@@ -93,6 +94,6 @@ class V4L2CaptureDelegate final
   DISALLOW_COPY_AND_ASSIGN(V4L2CaptureDelegate);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_H_
+#endif  // DEVICE_CAPTURE_VIDEO_LINUX_V4L2_CAPTURE_DELEGATE_H_
diff --git a/media/capture/video/linux/video_capture_device_chromeos.cc b/device/capture/video/linux/video_capture_device_chromeos.cc
similarity index 97%
rename from media/capture/video/linux/video_capture_device_chromeos.cc
rename to device/capture/video/linux/video_capture_device_chromeos.cc
index 1e6006c..573851b 100644
--- a/media/capture/video/linux/video_capture_device_chromeos.cc
+++ b/device/capture/video/linux/video_capture_device_chromeos.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/linux/video_capture_device_chromeos.h"
+#include "device/capture/video/linux/video_capture_device_chromeos.h"
 
 #include <stdint.h>
 
@@ -15,7 +15,7 @@
 #include "ui/display/display_observer.h"
 #include "ui/display/screen.h"
 
-namespace media {
+namespace device {
 
 // This is a delegate class used to transfer Display change events from the UI
 // thread to the media thread.
@@ -111,4 +111,4 @@ void VideoCaptureDeviceChromeOS::SetDisplayRotation(
     SetRotation(display.rotation() * 90);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/linux/video_capture_device_chromeos.h b/device/capture/video/linux/video_capture_device_chromeos.h
similarity index 76%
rename from media/capture/video/linux/video_capture_device_chromeos.h
rename to device/capture/video/linux/video_capture_device_chromeos.h
index cd33a5c..8fa0cf1 100644
--- a/media/capture/video/linux/video_capture_device_chromeos.h
+++ b/device/capture/video/linux/video_capture_device_chromeos.h
@@ -2,17 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_CHROMEOS_H_
-#define MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_CHROMEOS_H_
+#ifndef DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_CHROMEOS_H_
+#define DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_CHROMEOS_H_
 
 #include "base/macros.h"
-#include "media/capture/video/linux/video_capture_device_linux.h"
+#include "device/capture/video/linux/video_capture_device_linux.h"
 
 namespace display {
 class Display;
 }  // namespace display
 
-namespace media {
+namespace device {
 
 // This class is functionally the same as VideoCaptureDeviceLinux, with the
 // exception that it is aware of the orientation of the internal Display.  When
@@ -32,6 +32,6 @@ class VideoCaptureDeviceChromeOS : public VideoCaptureDeviceLinux {
   DISALLOW_IMPLICIT_CONSTRUCTORS(VideoCaptureDeviceChromeOS);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_CHROMEOS_H_
+#endif  // DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_CHROMEOS_H_
diff --git a/media/capture/video/linux/video_capture_device_factory_linux.cc b/device/capture/video/linux/video_capture_device_factory_linux.cc
similarity index 96%
rename from media/capture/video/linux/video_capture_device_factory_linux.cc
rename to device/capture/video/linux/video_capture_device_factory_linux.cc
index abe4337..fb6513a 100644
--- a/media/capture/video/linux/video_capture_device_factory_linux.cc
+++ b/device/capture/video/linux/video_capture_device_factory_linux.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/linux/video_capture_device_factory_linux.h"
+#include "device/capture/video/linux/video_capture_device_factory_linux.h"
 
 #include <errno.h>
 #include <fcntl.h>
@@ -22,11 +22,11 @@
 #endif
 
 #if defined(OS_CHROMEOS)
-#include "media/capture/video/linux/video_capture_device_chromeos.h"
+#include "device/capture/video/linux/video_capture_device_chromeos.h"
 #endif
-#include "media/capture/video/linux/video_capture_device_linux.h"
+#include "device/capture/video/linux/video_capture_device_linux.h"
 
-namespace media {
+namespace device {
 
 // USB VID and PID are both 4 bytes long.
 static const size_t kVidPidSize = 4;
@@ -116,7 +116,7 @@ static void GetSupportedFormatsForV4L2BufferType(
         VideoCaptureDeviceLinux::V4l2FourCcToChromiumPixelFormat(
             v4l2_format.pixelformat);
 
-    if (supported_format.pixel_format == PIXEL_FORMAT_UNKNOWN)
+    if (supported_format.pixel_format == media::PIXEL_FORMAT_UNKNOWN)
       continue;
 
     v4l2_frmsizeenum frame_size = {};
@@ -257,4 +257,4 @@ VideoCaptureDeviceFactory::CreateVideoCaptureDeviceFactory(
   return new VideoCaptureDeviceFactoryLinux(ui_task_runner);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/linux/video_capture_device_factory_linux.h b/device/capture/video/linux/video_capture_device_factory_linux.h
similarity index 78%
rename from media/capture/video/linux/video_capture_device_factory_linux.h
rename to device/capture/video/linux/video_capture_device_factory_linux.h
index 036be89..d97ba01 100644
--- a/media/capture/video/linux/video_capture_device_factory_linux.h
+++ b/device/capture/video/linux/video_capture_device_factory_linux.h
@@ -4,15 +4,15 @@
 
 // Implementation of a VideoCaptureDeviceFactoryLinux class.
 
-#ifndef MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_FACTORY_LINUX_H_
-#define MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_FACTORY_LINUX_H_
+#ifndef DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_FACTORY_LINUX_H_
+#define DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_FACTORY_LINUX_H_
 
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
 #include "base/macros.h"
 #include "media/base/video_capture_types.h"
 
-namespace media {
+namespace device {
 
 // Extension of VideoCaptureDeviceFactory to create and manipulate Linux
 // devices.
@@ -38,5 +38,5 @@ class CAPTURE_EXPORT VideoCaptureDeviceFactoryLinux
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceFactoryLinux);
 };
 
-}  // namespace media
-#endif  // MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_FACTORY_LINUX_H_
+}  // namespace device
+#endif  // DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_FACTORY_LINUX_H_
diff --git a/media/capture/video/linux/video_capture_device_linux.cc b/device/capture/video/linux/video_capture_device_linux.cc
similarity index 93%
rename from media/capture/video/linux/video_capture_device_linux.cc
rename to device/capture/video/linux/video_capture_device_linux.cc
index a52963e..9189ac5 100644
--- a/media/capture/video/linux/video_capture_device_linux.cc
+++ b/device/capture/video/linux/video_capture_device_linux.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/linux/video_capture_device_linux.h"
+#include "device/capture/video/linux/video_capture_device_linux.h"
 
 #include <stddef.h>
 
@@ -10,7 +10,7 @@
 
 #include "base/bind.h"
 #include "build/build_config.h"
-#include "media/capture/video/linux/v4l2_capture_delegate.h"
+#include "device/capture/video/linux/v4l2_capture_delegate.h"
 
 #if defined(OS_OPENBSD)
 #include <sys/videoio.h>
@@ -18,7 +18,7 @@
 #include <linux/videodev2.h>
 #endif
 
-namespace media {
+namespace device {
 
 // Translates Video4Linux pixel formats to Chromium pixel formats.
 // static
@@ -91,7 +91,7 @@ void VideoCaptureDeviceLinux::SetRotation(int rotation) {
 
 // static
 int VideoCaptureDeviceLinux::TranslatePowerLineFrequencyToV4L2(
-    PowerLineFrequency frequency) {
+    media::PowerLineFrequency frequency) {
   switch (frequency) {
     case media::PowerLineFrequency::FREQUENCY_50HZ:
       return V4L2_CID_POWER_LINE_FREQUENCY_50HZ;
@@ -103,4 +103,4 @@ int VideoCaptureDeviceLinux::TranslatePowerLineFrequencyToV4L2(
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/linux/video_capture_device_linux.h b/device/capture/video/linux/video_capture_device_linux.h
similarity index 82%
rename from media/capture/video/linux/video_capture_device_linux.h
rename to device/capture/video/linux/video_capture_device_linux.h
index 48e2a64..da34ec4 100644
--- a/media/capture/video/linux/video_capture_device_linux.h
+++ b/device/capture/video/linux/video_capture_device_linux.h
@@ -7,8 +7,8 @@
 // capturing so this implementation uses a Chromium thread for fetching frames
 // from V4L2.
 
-#ifndef MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_LINUX_H_
-#define MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_LINUX_H_
+#ifndef DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_LINUX_H_
+#define DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_LINUX_H_
 
 #include <stdint.h>
 
@@ -18,10 +18,10 @@
 #include "base/files/scoped_file.h"
 #include "base/macros.h"
 #include "base/threading/thread.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
 
-namespace media {
+namespace device {
 
 class V4L2CaptureDelegate;
 
@@ -44,7 +44,8 @@ class VideoCaptureDeviceLinux : public VideoCaptureDevice {
   void SetRotation(int rotation);
 
  private:
-  static int TranslatePowerLineFrequencyToV4L2(PowerLineFrequency frequency);
+  static int TranslatePowerLineFrequencyToV4L2(
+      media::PowerLineFrequency frequency);
 
   // Internal delegate doing the actual capture setting, buffer allocation and
   // circulation with the V4L2 API. Created and deleted in the thread where
@@ -58,6 +59,6 @@ class VideoCaptureDeviceLinux : public VideoCaptureDevice {
   DISALLOW_IMPLICIT_CONSTRUCTORS(VideoCaptureDeviceLinux);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_LINUX_H_
+#endif  // DEVICE_CAPTURE_VIDEO_LINUX_VIDEO_CAPTURE_DEVICE_LINUX_H_
diff --git a/media/capture/video/mac/DEPS b/device/capture/video/mac/DEPS
similarity index 100%
rename from media/capture/video/mac/DEPS
rename to device/capture/video/mac/DEPS
diff --git a/media/capture/video/mac/video_capture_device_avfoundation_mac.h b/device/capture/video/mac/video_capture_device_avfoundation_mac.h
similarity index 94%
rename from media/capture/video/mac/video_capture_device_avfoundation_mac.h
rename to device/capture/video/mac/video_capture_device_avfoundation_mac.h
index f6985dac..283bb49 100644
--- a/media/capture/video/mac/video_capture_device_avfoundation_mac.h
+++ b/device/capture/video/mac/video_capture_device_avfoundation_mac.h
@@ -2,19 +2,19 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_AVFOUNDATION_MAC_H_
-#define MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_AVFOUNDATION_MAC_H_
+#ifndef DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_AVFOUNDATION_MAC_H_
+#define DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_AVFOUNDATION_MAC_H_
 
 #import <Foundation/Foundation.h>
 
 #import "base/mac/scoped_nsobject.h"
 #include "base/synchronization/lock.h"
 #include "base/threading/thread_checker.h"
+#include "device/capture/video/video_capture_device.h"
 #import "media/base/mac/avfoundation_glue.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
 
-namespace media {
+namespace device {
 class VideoCaptureDeviceMac;
 }
 
@@ -124,4 +124,4 @@ class VideoCaptureDeviceMac;
 
 @end
 
-#endif  // MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_AVFOUNDATION_MAC_H_
+#endif  // DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_AVFOUNDATION_MAC_H_
diff --git a/media/capture/video/mac/video_capture_device_avfoundation_mac.mm b/device/capture/video/mac/video_capture_device_avfoundation_mac.mm
similarity index 99%
rename from media/capture/video/mac/video_capture_device_avfoundation_mac.mm
rename to device/capture/video/mac/video_capture_device_avfoundation_mac.mm
index 72685e8..3565580 100644
--- a/media/capture/video/mac/video_capture_device_avfoundation_mac.mm
+++ b/device/capture/video/mac/video_capture_device_avfoundation_mac.mm
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#import "media/capture/video/mac/video_capture_device_avfoundation_mac.h"
+#import "device/capture/video/mac/video_capture_device_avfoundation_mac.h"
 
 #import <CoreMedia/CoreMedia.h>
 #import <CoreVideo/CoreVideo.h>
@@ -14,9 +14,9 @@
 #include "base/mac/foundation_util.h"
 #include "base/mac/mac_util.h"
 #include "base/metrics/histogram_macros.h"
+#include "device/capture/video/mac/video_capture_device_mac.h"
 #include "media/base/timestamp_constants.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/mac/video_capture_device_mac.h"
 #include "ui/gfx/geometry/size.h"
 
 // Prefer MJPEG if frame width or height is larger than this.
diff --git a/media/capture/video/mac/video_capture_device_decklink_mac.h b/device/capture/video/mac/video_capture_device_decklink_mac.h
similarity index 91%
rename from media/capture/video/mac/video_capture_device_decklink_mac.h
rename to device/capture/video/mac/video_capture_device_decklink_mac.h
index 12bd3d7..0d99cf9 100644
--- a/media/capture/video/mac/video_capture_device_decklink_mac.h
+++ b/device/capture/video/mac/video_capture_device_decklink_mac.h
@@ -5,10 +5,10 @@
 // Implementation of VideoCaptureDevice class for Blackmagic video capture
 // devices by using the DeckLink SDK.
 
-#ifndef MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_DECKLINK_MAC_H_
-#define MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_DECKLINK_MAC_H_
+#ifndef DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_DECKLINK_MAC_H_
+#define DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_DECKLINK_MAC_H_
 
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
 #import <Foundation/Foundation.h>
 #include <stddef.h>
@@ -26,7 +26,7 @@ namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
+namespace device {
 
 // Extension of VideoCaptureDevice to create and manipulate Blackmagic devices.
 // Creates a reference counted |decklink_capture_delegate_| that does all the
@@ -89,6 +89,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceDeckLinkMac : public VideoCaptureDevice {
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceDeckLinkMac);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_DECKLINK_MAC_H_
+#endif  // DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_DECKLINK_MAC_H_
diff --git a/media/capture/video/mac/video_capture_device_decklink_mac.mm b/device/capture/video/mac/video_capture_device_decklink_mac.mm
similarity index 99%
rename from media/capture/video/mac/video_capture_device_decklink_mac.mm
rename to device/capture/video/mac/video_capture_device_decklink_mac.mm
index 54bb0cc..8e970d9 100644
--- a/media/capture/video/mac/video_capture_device_decklink_mac.mm
+++ b/device/capture/video/mac/video_capture_device_decklink_mac.mm
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/mac/video_capture_device_decklink_mac.h"
+#include "device/capture/video/mac/video_capture_device_decklink_mac.h"
 
 #include <utility>
 
@@ -330,7 +330,7 @@ void DeckLinkCaptureDelegate::ResetVideoCaptureDeviceReference() {
 
 }  // namespace
 
-namespace media {
+namespace device {
 
 static std::string JoinDeviceNameAndFormat(CFStringRef name,
                                            CFStringRef format) {
@@ -445,7 +445,7 @@ void VideoCaptureDeviceDeckLinkMac::EnumerateDeviceCapabilities(
       const media::VideoCaptureFormat format(
           gfx::Size(display_mode->GetWidth(), display_mode->GetHeight()),
           GetDisplayModeFrameRate(display_mode),
-          PIXEL_FORMAT_UNKNOWN);
+          media::PIXEL_FORMAT_UNKNOWN);
       supported_formats->push_back(format);
       DVLOG(2) << device.display_name << " "
                << VideoCaptureFormat::ToString(format);
@@ -508,4 +508,4 @@ void VideoCaptureDeviceDeckLinkMac::StopAndDeAllocate() {
     decklink_capture_delegate_->StopAndDeAllocate();
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/mac/video_capture_device_factory_mac.h b/device/capture/video/mac/video_capture_device_factory_mac.h
similarity index 75%
rename from media/capture/video/mac/video_capture_device_factory_mac.h
rename to device/capture/video/mac/video_capture_device_factory_mac.h
index ccf31dd..1b685f8 100644
--- a/media/capture/video/mac/video_capture_device_factory_mac.h
+++ b/device/capture/video/mac/video_capture_device_factory_mac.h
@@ -4,13 +4,13 @@
 
 // Implementation of a VideoCaptureDeviceFactory class for Mac.
 
-#ifndef MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_FACTORY_MAC_H_
-#define MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_FACTORY_MAC_H_
+#ifndef DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_FACTORY_MAC_H_
+#define DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_FACTORY_MAC_H_
 
 #include "base/macros.h"
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
-namespace media {
+namespace device {
 
 // Extension of VideoCaptureDeviceFactory to create and manipulate Mac devices.
 class CAPTURE_EXPORT VideoCaptureDeviceFactoryMac
@@ -30,6 +30,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceFactoryMac
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceFactoryMac);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_FACTORY_MAC_H_
+#endif  // DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_FACTORY_MAC_H_
diff --git a/media/capture/video/mac/video_capture_device_factory_mac.mm b/device/capture/video/mac/video_capture_device_factory_mac.mm
similarity index 94%
rename from media/capture/video/mac/video_capture_device_factory_mac.mm
rename to device/capture/video/mac/video_capture_device_factory_mac.mm
index abf547e..0b6455a 100644
--- a/media/capture/video/mac/video_capture_device_factory_mac.mm
+++ b/device/capture/video/mac/video_capture_device_factory_mac.mm
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/mac/video_capture_device_factory_mac.h"
+#include "device/capture/video/mac/video_capture_device_factory_mac.h"
 
 #import <IOKit/audio/IOAudioTypes.h>
 #include <stddef.h>
@@ -15,12 +15,12 @@
 #include "base/profiler/scoped_tracker.h"
 #include "base/strings/string_util.h"
 #include "base/task_runner_util.h"
+#import "device/capture/video/mac/video_capture_device_avfoundation_mac.h"
+#import "device/capture/video/mac/video_capture_device_decklink_mac.h"
+#include "device/capture/video/mac/video_capture_device_mac.h"
 #import "media/base/mac/avfoundation_glue.h"
-#import "media/capture/video/mac/video_capture_device_avfoundation_mac.h"
-#import "media/capture/video/mac/video_capture_device_decklink_mac.h"
-#include "media/capture/video/mac/video_capture_device_mac.h"
 
-namespace media {
+namespace device {
 
 // Blacklisted devices are identified by a characteristic trailing substring of
 // uniqueId. At the moment these are just Blackmagic devices.
@@ -133,4 +133,4 @@ VideoCaptureDeviceFactory::CreateVideoCaptureDeviceFactory(
   return new VideoCaptureDeviceFactoryMac();
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/mac/video_capture_device_factory_mac_unittest.mm b/device/capture/video/mac/video_capture_device_factory_mac_unittest.mm
similarity index 81%
rename from media/capture/video/mac/video_capture_device_factory_mac_unittest.mm
rename to device/capture/video/mac/video_capture_device_factory_mac_unittest.mm
index 209c3ea..7a54ecf 100644
--- a/media/capture/video/mac/video_capture_device_factory_mac_unittest.mm
+++ b/device/capture/video/mac/video_capture_device_factory_mac_unittest.mm
@@ -1,12 +1,12 @@
 // Copyright 2014 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+#include "device/capture/video/mac/video_capture_device_factory_mac.h"
+#include "device/capture/video/mac/video_capture_device_mac.h"
 #import "media/base/mac/avfoundation_glue.h"
-#include "media/capture/video/mac/video_capture_device_factory_mac.h"
-#include "media/capture/video/mac/video_capture_device_mac.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
-namespace media {
+namespace device {
 
 TEST(VideoCaptureDeviceFactoryMacTest, ListDevicesAVFoundation) {
   AVFoundationGlue::InitializeAVFoundation();
@@ -22,4 +22,4 @@ TEST(VideoCaptureDeviceFactoryMacTest, ListDevicesAVFoundation) {
     EXPECT_EQ(VideoCaptureApi::MACOSX_AVFOUNDATION, descriptor.capture_api);
 }
 
-};  // namespace media
+};  // namespace device
diff --git a/media/capture/video/mac/video_capture_device_mac.h b/device/capture/video/mac/video_capture_device_mac.h
similarity index 93%
rename from media/capture/video/mac/video_capture_device_mac.h
rename to device/capture/video/mac/video_capture_device_mac.h
index c084ba1..97a2b1b 100644
--- a/media/capture/video/mac/video_capture_device_mac.h
+++ b/device/capture/video/mac/video_capture_device_mac.h
@@ -6,8 +6,8 @@
 // native capture API. AVFoundation is available in versions 10.7 (Lion) and
 // later.
 
-#ifndef MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
-#define MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
+#ifndef DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
+#define DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
 
 #import <Foundation/Foundation.h>
 #include <stdint.h>
@@ -19,8 +19,8 @@
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
 #include "base/memory/weak_ptr.h"
+#include "device/capture/video/video_capture_device.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
 
 @class VideoCaptureDeviceAVFoundation;
 
@@ -48,7 +48,7 @@ CAPTURE_EXPORT
 - (int32_t)transportType;
 @end
 
-namespace media {
+namespace device {
 
 // Called by VideoCaptureManager to open, close and start, stop Mac video
 // capture devices.
@@ -124,6 +124,6 @@ class VideoCaptureDeviceMac : public VideoCaptureDevice {
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceMac);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
+#endif  // DEVICE_CAPTURE_VIDEO_MAC_VIDEO_CAPTURE_DEVICE_MAC_H_
diff --git a/media/capture/video/mac/video_capture_device_mac.mm b/device/capture/video/mac/video_capture_device_mac.mm
similarity index 96%
rename from media/capture/video/mac/video_capture_device_mac.mm
rename to device/capture/video/mac/video_capture_device_mac.mm
index 8a87ec9..340ad5a 100644
--- a/media/capture/video/mac/video_capture_device_mac.mm
+++ b/device/capture/video/mac/video_capture_device_mac.mm
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/mac/video_capture_device_mac.h"
+#include "device/capture/video/mac/video_capture_device_mac.h"
 
 #include <IOKit/IOCFPlugIn.h>
 #include <IOKit/usb/IOUSBLib.h>
@@ -23,9 +23,9 @@
 #include "base/strings/string_number_conversions.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "base/time/time.h"
+#import "device/capture/video/mac/video_capture_device_avfoundation_mac.h"
 #import "media/base/mac/avfoundation_glue.h"
 #include "media/base/timestamp_constants.h"
-#import "media/capture/video/mac/video_capture_device_avfoundation_mac.h"
 #include "ui/gfx/geometry/size.h"
 
 @implementation DeviceNameAndTransportType
@@ -48,7 +48,7 @@
 
 @end  // @implementation DeviceNameAndTransportType
 
-namespace media {
+namespace device {
 
 // Mac specific limits for minimum and maximum frame rate.
 const float kMinFrameRate = 1.0f;
@@ -162,7 +162,7 @@ static bool FindVideoControlInterfaceInDeviceInterface(
 // set the appropriate Power Line frequency for flicker removal.
 static void SetAntiFlickerInVideoControlInterface(
     IOCFPlugInInterface** plugin_interface,
-    const PowerLineFrequency frequency) {
+    const media::PowerLineFrequency frequency) {
   // Create, the control interface for the found plugin, and release
   // the intermediate plugin.
   IOUSBInterfaceInterface** control_interface = NULL;
@@ -223,7 +223,7 @@ static void SetAntiFlickerInVideoControlInterface(
   command.wLength = kPuPowerLineFrequencyControlCommandSize;
   command.wLenDone = 0;
   int power_line_flag_value =
-      (frequency == PowerLineFrequency::FREQUENCY_50HZ) ? k50Hz : k60Hz;
+      (frequency == media::PowerLineFrequency::FREQUENCY_50HZ) ? k50Hz : k60Hz;
   command.pData = &power_line_flag_value;
 
   IOReturn ret =
@@ -242,10 +242,11 @@ static void SetAntiFlickerInVideoControlInterface(
 // devices matching the specified |vendor_id| and |product_id|; for each
 // matching device, a device interface, and inside it a video control interface
 // are created. The latter is used to a send a power frequency setting command.
-static void SetAntiFlickerInUsbDevice(const int vendor_id,
-                                      const int product_id,
-                                      const PowerLineFrequency frequency) {
-  if (frequency == PowerLineFrequency::FREQUENCY_DEFAULT)
+static void SetAntiFlickerInUsbDevice(
+    const int vendor_id,
+    const int product_id,
+    const media::PowerLineFrequency frequency) {
+  if (frequency == media::PowerLineFrequency::FREQUENCY_DEFAULT)
     return;
   DVLOG(1) << "Setting Power Line Frequency to " << static_cast<int>(frequency)
            << " Hz, device " << std::hex << vendor_id << "-" << product_id;
@@ -333,7 +334,7 @@ void VideoCaptureDeviceMac::AllocateAndStart(
                std::min(params.requested_format.frame_rate, kMaxFrameRate));
   // Leave the pixel format selection to AVFoundation. The pixel format
   // will be passed to |ReceiveFrame|.
-  capture_format_.pixel_format = PIXEL_FORMAT_UNKNOWN;
+  capture_format_.pixel_format = media::PIXEL_FORMAT_UNKNOWN;
 
   if (!UpdateCaptureResolution())
     return;
@@ -495,4 +496,4 @@ bool VideoCaptureDeviceMac::UpdateCaptureResolution() {
   return true;
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/scoped_result_callback.h b/device/capture/video/scoped_result_callback.h
similarity index 87%
rename from media/capture/video/scoped_result_callback.h
rename to device/capture/video/scoped_result_callback.h
index af4edc1..8efab2f 100644
--- a/media/capture/video/scoped_result_callback.h
+++ b/device/capture/video/scoped_result_callback.h
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_SCOPED_RESULT_CALLBACK_H_
-#define MEDIA_CAPTURE_VIDEO_SCOPED_RESULT_CALLBACK_H_
+#ifndef DEVICE_CAPTURE_VIDEO_SCOPED_RESULT_CALLBACK_H_
+#define DEVICE_CAPTURE_VIDEO_SCOPED_RESULT_CALLBACK_H_
 
 #include "base/callback.h"
 #include "base/callback_helpers.h"
 #include "base/macros.h"
 
-namespace media {
+namespace device {
 
 // This class guarantees that |callback_| has either been called or will pass it
 // to |on_error_callback_| on destruction. Inspired by ScopedWebCallbacks<>.
@@ -51,6 +51,6 @@ class ScopedResultCallback {
   DISALLOW_COPY_AND_ASSIGN(ScopedResultCallback);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_SCOPED_RESULT_CALLBACK_H_
+#endif  // DEVICE_CAPTURE_VIDEO_SCOPED_RESULT_CALLBACK_H_
diff --git a/media/capture/video/video_capture_device.cc b/device/capture/video/video_capture_device.cc
similarity index 81%
rename from media/capture/video/video_capture_device.cc
rename to device/capture/video/video_capture_device.cc
index 5da33f0..26289d71 100644
--- a/media/capture/video/video_capture_device.cc
+++ b/device/capture/video/video_capture_device.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
 #include "base/command_line.h"
 #include "base/i18n/timezone.h"
@@ -11,7 +11,7 @@
 #include "build/build_config.h"
 #include "media/base/media_switches.h"
 
-namespace media {
+namespace device {
 
 VideoCaptureDevice::Client::Buffer::~Buffer() {
 }
@@ -22,16 +22,17 @@ VideoCaptureDevice::~VideoCaptureDevice() {
 void VideoCaptureDevice::GetPhotoCapabilities(
     GetPhotoCapabilitiesCallback callback) {}
 
-void VideoCaptureDevice::SetPhotoOptions(mojom::PhotoSettingsPtr settings,
-                                         SetPhotoOptionsCallback callback) {}
+void VideoCaptureDevice::SetPhotoOptions(
+    media::mojom::PhotoSettingsPtr settings,
+    SetPhotoOptionsCallback callback) {}
 
 void VideoCaptureDevice::TakePhoto(TakePhotoCallback callback) {}
 
-PowerLineFrequency VideoCaptureDevice::GetPowerLineFrequencyForLocation()
+media::PowerLineFrequency VideoCaptureDevice::GetPowerLineFrequencyForLocation()
     const {
   const std::string current_country = base::CountryCodeForCurrentTimezone();
   if (current_country.empty())
-    return PowerLineFrequency::FREQUENCY_DEFAULT;
+    return media::PowerLineFrequency::FREQUENCY_DEFAULT;
   // Sorted out list of countries with 60Hz power line frequency, from
   // http://en.wikipedia.org/wiki/Mains_electricity_by_country
   const char* countries_using_60Hz[] = {
@@ -48,7 +49,7 @@ PowerLineFrequency VideoCaptureDevice::GetPowerLineFrequencyForLocation()
   return media::PowerLineFrequency::FREQUENCY_60HZ;
 }
 
-PowerLineFrequency VideoCaptureDevice::GetPowerLineFrequency(
+media::PowerLineFrequency VideoCaptureDevice::GetPowerLineFrequency(
     const VideoCaptureParams& params) const {
   switch (params.power_line_frequency) {
     case media::PowerLineFrequency::FREQUENCY_50HZ:  // fall through
@@ -59,4 +60,4 @@ PowerLineFrequency VideoCaptureDevice::GetPowerLineFrequency(
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/video_capture_device.h b/device/capture/video/video_capture_device.h
similarity index 90%
rename from media/capture/video/video_capture_device.h
rename to device/capture/video/video_capture_device.h
index cbdc8ad..b89efd2 100644
--- a/media/capture/video/video_capture_device.h
+++ b/device/capture/video/video_capture_device.h
@@ -9,8 +9,8 @@
 // VideoCaptureManager. Capturing is done on other threads, depending on the OS
 // specific implementation.
 
-#ifndef MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_H_
-#define MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_H_
+#ifndef DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_H_
+#define DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_H_
 
 #include <stddef.h>
 #include <stdint.h>
@@ -26,11 +26,11 @@
 #include "base/single_thread_task_runner.h"
 #include "base/time/time.h"
 #include "build/build_config.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/video/scoped_result_callback.h"
+#include "device/capture/video/video_capture_device_descriptor.h"
 #include "media/base/video_capture_types.h"
 #include "media/base/video_frame.h"
-#include "media/capture/capture_export.h"
-#include "media/capture/video/scoped_result_callback.h"
-#include "media/capture/video/video_capture_device_descriptor.h"
 #include "media/mojo/interfaces/image_capture.mojom.h"
 #include "mojo/public/cpp/bindings/array.h"
 #include "ui/gfx/gpu_memory_buffer.h"
@@ -39,7 +39,15 @@ namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
+namespace device {
+
+using media::VideoCaptureFormat;
+using media::VideoCaptureFormats;
+using media::VideoCaptureParams;
+using media::VideoFrame;
+using media::VideoFrameMetadata;
+using media::VideoPixelFormat;
+using media::VideoPixelStorage;
 
 class CAPTURE_EXPORT VideoCaptureDevice {
  public:
@@ -181,33 +189,33 @@ class CAPTURE_EXPORT VideoCaptureDevice {
   virtual void StopAndDeAllocate() = 0;
 
   // Retrieve the photo capabilities of the device (e.g. zoom levels etc).
-  using GetPhotoCapabilitiesCallback =
-      ScopedResultCallback<base::Callback<void(mojom::PhotoCapabilitiesPtr)>>;
+  using GetPhotoCapabilitiesCallback = ScopedResultCallback<
+      base::Callback<void(media::mojom::PhotoCapabilitiesPtr)>>;
   virtual void GetPhotoCapabilities(GetPhotoCapabilitiesCallback callback);
 
   using SetPhotoOptionsCallback =
       ScopedResultCallback<base::Callback<void(bool)>>;
-  virtual void SetPhotoOptions(mojom::PhotoSettingsPtr settings,
+  virtual void SetPhotoOptions(media::mojom::PhotoSettingsPtr settings,
                                SetPhotoOptionsCallback callback);
 
   // Asynchronously takes a photo, possibly reconfiguring the capture objects
   // and/or interrupting the capture flow. Runs |callback| on the thread
   // where TakePhoto() is called, if the photo was successfully taken.
   using TakePhotoCallback =
-      ScopedResultCallback<base::Callback<void(mojom::BlobPtr blob)>>;
+      ScopedResultCallback<base::Callback<void(media::mojom::BlobPtr blob)>>;
   virtual void TakePhoto(TakePhotoCallback callback);
 
   // Gets the power line frequency, either from the params if specified by the
   // user or from the current system time zone.
-  PowerLineFrequency GetPowerLineFrequency(
+  media::PowerLineFrequency GetPowerLineFrequency(
       const VideoCaptureParams& params) const;
 
  private:
   // Gets the power line frequency from the current system time zone if this is
   // defined, otherwise returns 0.
-  PowerLineFrequency GetPowerLineFrequencyForLocation() const;
+  media::PowerLineFrequency GetPowerLineFrequencyForLocation() const;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_H_
+#endif  // DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_H_
diff --git a/media/capture/video/video_capture_device_descriptor.cc b/device/capture/video/video_capture_device_descriptor.cc
similarity index 95%
rename from media/capture/video/video_capture_device_descriptor.cc
rename to device/capture/video/video_capture_device_descriptor.cc
index be94776..92d6538 100644
--- a/media/capture/video/video_capture_device_descriptor.cc
+++ b/device/capture/video/video_capture_device_descriptor.cc
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/video_capture_device_descriptor.h"
+#include "device/capture/video/video_capture_device_descriptor.h"
 
 #include "base/logging.h"
 
-namespace media {
+namespace device {
 
 VideoCaptureDeviceDescriptor::VideoCaptureDeviceDescriptor()
     : capture_api(VideoCaptureApi::UNKNOWN),
@@ -74,4 +74,4 @@ std::string VideoCaptureDeviceDescriptor::GetNameAndModel() const {
   return display_name + " (" + model_id + ")";
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/video_capture_device_descriptor.h b/device/capture/video/video_capture_device_descriptor.h
similarity index 90%
rename from media/capture/video/video_capture_device_descriptor.h
rename to device/capture/video/video_capture_device_descriptor.h
index 9bfbdde..e586e10 100644
--- a/media/capture/video/video_capture_device_descriptor.h
+++ b/device/capture/video/video_capture_device_descriptor.h
@@ -2,18 +2,18 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_DESCRIPTOR_H_
-#define MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_DESCRIPTOR_H_
+#ifndef DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_DESCRIPTOR_H_
+#define DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_DESCRIPTOR_H_
 
 #include <list>
 #include <string>
 
-#include "media/capture/capture_export.h"
+#include "device/capture/capture_export.h"
 
-namespace media {
+namespace device {
 
 // A Java counterpart will be generated for this enum.
-// GENERATED_JAVA_ENUM_PACKAGE: org.chromium.media
+// GENERATED_JAVA_ENUM_PACKAGE: org.chromium.device
 enum class VideoCaptureApi {
   LINUX_V4L2_SINGLE_PLANE,
   WIN_MEDIA_FOUNDATION,
@@ -86,6 +86,6 @@ struct CAPTURE_EXPORT VideoCaptureDeviceDescriptor {
 
 using VideoCaptureDeviceDescriptors = std::list<VideoCaptureDeviceDescriptor>;
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_DESCRIPTOR_H_
+#endif  // DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_DESCRIPTOR_H_
diff --git a/media/capture/video/video_capture_device_factory.cc b/device/capture/video/video_capture_device_factory.cc
similarity index 85%
rename from media/capture/video/video_capture_device_factory.cc
rename to device/capture/video/video_capture_device_factory.cc
index adee438..c5d954e 100644
--- a/media/capture/video/video_capture_device_factory.cc
+++ b/device/capture/video/video_capture_device_factory.cc
@@ -2,17 +2,17 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
 #include <utility>
 
 #include "base/command_line.h"
 #include "build/build_config.h"
+#include "device/capture/video/fake_video_capture_device_factory.h"
+#include "device/capture/video/file_video_capture_device_factory.h"
 #include "media/base/media_switches.h"
-#include "media/capture/video/fake_video_capture_device_factory.h"
-#include "media/capture/video/file_video_capture_device_factory.h"
 
-namespace media {
+namespace device {
 
 // static
 std::unique_ptr<VideoCaptureDeviceFactory>
@@ -25,10 +25,10 @@ VideoCaptureDeviceFactory::CreateFactory(
   if (command_line->HasSwitch(switches::kUseFakeDeviceForMediaStream)) {
     if (command_line->HasSwitch(switches::kUseFileForFakeVideoCapture)) {
       return std::unique_ptr<VideoCaptureDeviceFactory>(
-          new media::FileVideoCaptureDeviceFactory());
+          new FileVideoCaptureDeviceFactory());
     } else {
       return std::unique_ptr<VideoCaptureDeviceFactory>(
-          new media::FakeVideoCaptureDeviceFactory());
+          new FakeVideoCaptureDeviceFactory());
     }
   } else {
     // |ui_task_runner| is needed for the Linux ChromeOS factory to retrieve
@@ -66,4 +66,4 @@ VideoCaptureDeviceFactory::CreateVideoCaptureDeviceFactory(
 }
 #endif
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/video_capture_device_factory.h b/device/capture/video/video_capture_device_factory.h
similarity index 89%
rename from media/capture/video/video_capture_device_factory.h
rename to device/capture/video/video_capture_device_factory.h
index 33da232..20b1040 100644
--- a/media/capture/video/video_capture_device_factory.h
+++ b/device/capture/video/video_capture_device_factory.h
@@ -2,14 +2,14 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#ifndef MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_FACTORY_H_
-#define MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#ifndef DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#define DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_FACTORY_H_
 
 #include "base/macros.h"
 #include "base/threading/thread_checker.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
-namespace media {
+namespace device {
 
 // VideoCaptureDeviceFactory is the base class for creation of video capture
 // devices in the different platforms. VCDFs are created by MediaStreamManager
@@ -62,6 +62,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceFactory {
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceFactory);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_FACTORY_H_
+#endif  // DEVICE_CAPTURE_VIDEO_VIDEO_CAPTURE_DEVICE_FACTORY_H_
diff --git a/media/capture/video/video_capture_device_unittest.cc b/device/capture/video/video_capture_device_unittest.cc
similarity index 92%
rename from media/capture/video/video_capture_device_unittest.cc
rename to device/capture/video/video_capture_device_unittest.cc
index a684a3b..616fb35 100644
--- a/media/capture/video/video_capture_device_unittest.cc
+++ b/device/capture/video/video_capture_device_unittest.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/video/video_capture_device.h"
 
 #include <stddef.h>
 #include <stdint.h>
@@ -19,26 +19,26 @@
 #include "base/threading/thread.h"
 #include "base/threading/thread_task_runner_handle.h"
 #include "build/build_config.h"
+#include "device/capture/video/video_capture_device_factory.h"
 #include "media/base/bind_to_current_loop.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device_factory.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 #if defined(OS_WIN)
 #include "base/win/scoped_com_initializer.h"
 #include "base/win/windows_version.h"  // For fine-grained suppression.
-#include "media/capture/video/win/video_capture_device_factory_win.h"
+#include "device/capture/video/win/video_capture_device_factory_win.h"
 #endif
 
 #if defined(OS_MACOSX)
+#include "device/capture/video/mac/video_capture_device_factory_mac.h"
 #include "media/base/mac/avfoundation_glue.h"
-#include "media/capture/video/mac/video_capture_device_factory_mac.h"
 #endif
 
 #if defined(OS_ANDROID)
 #include "base/android/jni_android.h"
-#include "media/capture/video/android/video_capture_device_android.h"
+#include "device/capture/video/android/video_capture_device_android.h"
 #endif
 
 #if defined(OS_MACOSX)
@@ -78,7 +78,7 @@
 using ::testing::_;
 using ::testing::SaveArg;
 
-namespace media {
+namespace device {
 namespace {
 
 class MockVideoCaptureClient : public VideoCaptureDevice::Client {
@@ -145,7 +145,7 @@ class MockVideoCaptureClient : public VideoCaptureDevice::Client {
 class MockImageCaptureClient : public base::RefCounted<MockImageCaptureClient> {
  public:
   // GMock doesn't support move-only arguments, so we use this forward method.
-  void DoOnPhotoTaken(mojom::BlobPtr blob) {
+  void DoOnPhotoTaken(media::mojom::BlobPtr blob) {
     EXPECT_STREQ("image/jpeg", blob->mime_type.c_str());
     ASSERT_GT(blob->data.size(), 4u);
     // Check some bytes that univocally identify |data| as a JPEG File.
@@ -158,7 +158,7 @@ class MockImageCaptureClient : public base::RefCounted<MockImageCaptureClient> {
   }
   MOCK_METHOD0(OnCorrectPhotoTaken, void(void));
   MOCK_METHOD1(OnTakePhotoFailure,
-               void(const base::Callback<void(mojom::BlobPtr)>&));
+               void(const base::Callback<void(media::mojom::BlobPtr)>&));
 
  private:
   friend class base::RefCounted<MockImageCaptureClient>;
@@ -260,7 +260,7 @@ class VideoCaptureDeviceTest : public testing::TestWithParam<gfx::Size> {
         }
       }
     }
-    DVLOG_IF(1, pixel_format != PIXEL_FORMAT_MAX)
+    DVLOG_IF(1, pixel_format != media::PIXEL_FORMAT_MAX)
         << "No camera can capture the"
         << " format: " << VideoPixelFormatToString(pixel_format);
     return std::unique_ptr<VideoCaptureDeviceDescriptor>();
@@ -327,7 +327,7 @@ TEST_F(VideoCaptureDeviceTest, MAYBE_OpenInvalidDevice) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(640, 480);
   capture_params.requested_format.frame_rate = 30;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
   device->AllocateAndStart(capture_params, std::move(video_capture_client_));
   device->StopAndDeAllocate();
 #endif
@@ -357,13 +357,13 @@ TEST_P(VideoCaptureDeviceTest, CaptureWithSize) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(width, height);
   capture_params.requested_format.frame_rate = 30.0f;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
   device->AllocateAndStart(capture_params, std::move(video_capture_client_));
   // Get captured video frames.
   WaitForCapturedFrame();
   EXPECT_EQ(last_format().frame_size.width(), width);
   EXPECT_EQ(last_format().frame_size.height(), height);
-  if (last_format().pixel_format != PIXEL_FORMAT_MJPEG)
+  if (last_format().pixel_format != media::PIXEL_FORMAT_MJPEG)
     EXPECT_EQ(size.GetArea(), last_format().frame_size.GetArea());
   device->StopAndDeAllocate();
 }
@@ -393,13 +393,13 @@ TEST_F(VideoCaptureDeviceTest, MAYBE_AllocateBadSize) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(637, 472);
   capture_params.requested_format.frame_rate = 35;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
   device->AllocateAndStart(capture_params, std::move(video_capture_client_));
   WaitForCapturedFrame();
   device->StopAndDeAllocate();
   EXPECT_EQ(last_format().frame_size.width(), input_size.width());
   EXPECT_EQ(last_format().frame_size.height(), input_size.height());
-  if (last_format().pixel_format != PIXEL_FORMAT_MJPEG)
+  if (last_format().pixel_format != media::PIXEL_FORMAT_MJPEG)
     EXPECT_EQ(input_size.GetArea(), last_format().frame_size.GetArea());
 }
 
@@ -426,7 +426,7 @@ TEST_F(VideoCaptureDeviceTest, DISABLED_ReAllocateCamera) {
     VideoCaptureParams capture_params;
     capture_params.requested_format.frame_size = resolution;
     capture_params.requested_format.frame_rate = 30;
-    capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+    capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
     device->AllocateAndStart(capture_params, std::move(video_capture_client_));
     device->StopAndDeAllocate();
   }
@@ -435,7 +435,7 @@ TEST_F(VideoCaptureDeviceTest, DISABLED_ReAllocateCamera) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(320, 240);
   capture_params.requested_format.frame_rate = 30;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
 
   ResetWithNewClient();
   std::unique_ptr<VideoCaptureDevice> device(
@@ -466,7 +466,7 @@ TEST_F(VideoCaptureDeviceTest, DeAllocateCameraWhileRunning) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(640, 480);
   capture_params.requested_format.frame_rate = 30;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
   device->AllocateAndStart(capture_params, std::move(video_capture_client_));
   // Get captured video frames.
   WaitForCapturedFrame();
@@ -479,7 +479,7 @@ TEST_F(VideoCaptureDeviceTest, DeAllocateCameraWhileRunning) {
 // Start the camera in 720p to capture MJPEG instead of a raw format.
 TEST_F(VideoCaptureDeviceTest, MAYBE_CaptureMjpeg) {
   std::unique_ptr<VideoCaptureDeviceDescriptor> device_descriptor =
-      GetFirstDeviceDescriptorSupportingPixelFormat(PIXEL_FORMAT_MJPEG);
+      GetFirstDeviceDescriptorSupportingPixelFormat(media::PIXEL_FORMAT_MJPEG);
   if (!device_descriptor) {
     VLOG(1) << "No camera supports MJPEG format. Exiting test.";
     return;
@@ -501,25 +501,25 @@ TEST_F(VideoCaptureDeviceTest, MAYBE_CaptureMjpeg) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(1280, 720);
   capture_params.requested_format.frame_rate = 30;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_MJPEG;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_MJPEG;
   device->AllocateAndStart(capture_params, std::move(video_capture_client_));
   // Get captured video frames.
   WaitForCapturedFrame();
   // Verify we get MJPEG from the device. Not all devices can capture 1280x720
   // @ 30 fps, so we don't care about the exact resolution we get.
-  EXPECT_EQ(last_format().pixel_format, PIXEL_FORMAT_MJPEG);
+  EXPECT_EQ(last_format().pixel_format, media::PIXEL_FORMAT_MJPEG);
   EXPECT_GE(static_cast<size_t>(1280 * 720),
             last_format().ImageAllocationSize());
   device->StopAndDeAllocate();
 }
 
 TEST_F(VideoCaptureDeviceTest, GetDeviceSupportedFormats) {
-  // Use PIXEL_FORMAT_MAX to iterate all device names for testing
+  // Use media::PIXEL_FORMAT_MAX to iterate all device names for testing
   // GetDeviceSupportedFormats().
   std::unique_ptr<VideoCaptureDeviceDescriptor> device_descriptor =
-      GetFirstDeviceDescriptorSupportingPixelFormat(PIXEL_FORMAT_MAX);
-  // Verify no camera returned for PIXEL_FORMAT_MAX. Nothing else to test here
-  // since we cannot forecast the hardware capabilities.
+      GetFirstDeviceDescriptorSupportingPixelFormat(media::PIXEL_FORMAT_MAX);
+  // Verify no camera returned for media::PIXEL_FORMAT_MAX. Nothing else to test
+  // here since we cannot forecast the hardware capabilities.
   ASSERT_FALSE(device_descriptor);
 }
 
@@ -540,7 +540,7 @@ TEST_F(VideoCaptureDeviceTest, MAYBE_TakePhoto) {
   VideoCaptureParams capture_params;
   capture_params.requested_format.frame_size.SetSize(640, 480);
   capture_params.requested_format.frame_rate = 30;
-  capture_params.requested_format.pixel_format = PIXEL_FORMAT_I420;
+  capture_params.requested_format.pixel_format = media::PIXEL_FORMAT_I420;
   device->AllocateAndStart(capture_params, std::move(video_capture_client_));
   WaitForCapturedFrame();
 
@@ -557,4 +557,4 @@ TEST_F(VideoCaptureDeviceTest, MAYBE_TakePhoto) {
   device->StopAndDeAllocate();
 }
 
-};  // namespace media
+};  // namespace device
diff --git a/media/capture/video/win/capability_list_win.cc b/device/capture/video/win/capability_list_win.cc
similarity index 95%
rename from media/capture/video/win/capability_list_win.cc
rename to device/capture/video/win/capability_list_win.cc
index 32cbb61..f6b06b6 100644
--- a/media/capture/video/win/capability_list_win.cc
+++ b/device/capture/video/win/capability_list_win.cc
@@ -2,15 +2,15 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/base/video_capture_types.h"
-#include "media/capture/video/win/capability_list_win.h"
+#include "device/capture/video/win/capability_list_win.h"
 
 #include <algorithm>
 #include <functional>
 
 #include "base/logging.h"
+#include "media/base/video_capture_types.h"
 
-namespace media {
+namespace device {
 
 static bool CompareCapability(const VideoCaptureFormat& requested,
                               const CapabilityWin& capability_lhs,
@@ -53,4 +53,4 @@ const CapabilityWin& GetBestMatchedCapability(
   return *best_match;
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/capability_list_win.h b/device/capture/video/win/capability_list_win.h
similarity index 84%
rename from media/capture/video/win/capability_list_win.h
rename to device/capture/video/win/capability_list_win.h
index 526f67c..df4dbfc 100644
--- a/media/capture/video/win/capability_list_win.h
+++ b/device/capture/video/win/capability_list_win.h
@@ -6,15 +6,15 @@
 // DirectShow is used for capturing. DirectShow provide its own threads
 // for capturing.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_CAPABILITY_LIST_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_CAPABILITY_LIST_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_CAPABILITY_LIST_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_CAPABILITY_LIST_WIN_H_
 
 #include <list>
 #include <windows.h>
 
 #include "media/base/video_capture_types.h"
 
-namespace media {
+namespace device {
 
 struct CapabilityWin {
   CapabilityWin(int index, const VideoCaptureFormat& format)
@@ -41,6 +41,6 @@ const CapabilityWin& GetBestMatchedCapability(
     const VideoCaptureFormat& requested,
     const CapabilityList& capabilities);
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_CAPABILITY_LIST_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_CAPABILITY_LIST_WIN_H_
diff --git a/media/capture/video/win/filter_base_win.cc b/device/capture/video/win/filter_base_win.cc
similarity index 96%
rename from media/capture/video/win/filter_base_win.cc
rename to device/capture/video/win/filter_base_win.cc
index 166b860..c87b686 100644
--- a/media/capture/video/win/filter_base_win.cc
+++ b/device/capture/video/win/filter_base_win.cc
@@ -2,11 +2,9 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/filter_base_win.h"
+#include "device/capture/video/win/filter_base_win.h"
 
-#pragma comment(lib, "strmiids.lib")
-
-namespace media {
+namespace device {
 
 // Implement IEnumPins.
 class PinEnumerator final : public IEnumPins,
@@ -170,4 +168,4 @@ ULONG STDMETHODCALLTYPE FilterBase::Release() {
 FilterBase::~FilterBase() {
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/filter_base_win.h b/device/capture/video/win/filter_base_win.h
similarity index 90%
rename from media/capture/video/win/filter_base_win.h
rename to device/capture/video/win/filter_base_win.h
index 57329d4..0029b25 100644
--- a/media/capture/video/win/filter_base_win.h
+++ b/device/capture/video/win/filter_base_win.h
@@ -5,8 +5,8 @@
 // Implement a simple base class for DirectShow filters. It may only be used in
 // a single threaded apartment.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_FILTER_BASE_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_FILTER_BASE_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_FILTER_BASE_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_FILTER_BASE_WIN_H_
 
 // Avoid including strsafe.h via dshow as it will cause build warnings.
 #define NO_DSHOW_STRSAFE
@@ -17,7 +17,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/win/scoped_comptr.h"
 
-namespace media {
+namespace device {
 
 class FilterBase : public IBaseFilter, public base::RefCounted<FilterBase> {
  public:
@@ -71,6 +71,6 @@ class FilterBase : public IBaseFilter, public base::RefCounted<FilterBase> {
   DISALLOW_COPY_AND_ASSIGN(FilterBase);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_FILTER_BASE_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_FILTER_BASE_WIN_H_
diff --git a/media/capture/video/win/pin_base_win.cc b/device/capture/video/win/pin_base_win.cc
similarity index 98%
rename from media/capture/video/win/pin_base_win.cc
rename to device/capture/video/win/pin_base_win.cc
index 3f52194..0bf1e4c 100644
--- a/media/capture/video/win/pin_base_win.cc
+++ b/device/capture/video/win/pin_base_win.cc
@@ -2,11 +2,11 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/pin_base_win.h"
+#include "device/capture/video/win/pin_base_win.h"
 
 #include "base/logging.h"
 
-namespace media {
+namespace device {
 
 // Implement IEnumPins.
 class TypeEnumerator final : public IEnumMediaTypes,
@@ -282,4 +282,4 @@ STDMETHODIMP_(ULONG) PinBase::Release() {
 PinBase::~PinBase() {
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/pin_base_win.h b/device/capture/video/win/pin_base_win.h
similarity index 94%
rename from media/capture/video/win/pin_base_win.h
rename to device/capture/video/win/pin_base_win.h
index 43cfc49..6c55146 100644
--- a/media/capture/video/win/pin_base_win.h
+++ b/device/capture/video/win/pin_base_win.h
@@ -5,8 +5,8 @@
 // Implement a simple base class for a DirectShow input pin. It may only be
 // used in a single threaded apartment.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_PIN_BASE_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_PIN_BASE_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_PIN_BASE_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_PIN_BASE_WIN_H_
 
 // Avoid including strsafe.h via dshow as it will cause build warnings.
 #define NO_DSHOW_STRSAFE
@@ -15,7 +15,7 @@
 #include "base/memory/ref_counted.h"
 #include "base/win/scoped_comptr.h"
 
-namespace media {
+namespace device {
 
 class PinBase : public IPin,
                 public IMemInputPin,
@@ -106,6 +106,6 @@ class PinBase : public IPin,
   IBaseFilter* owner_;
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_PIN_BASE_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_PIN_BASE_WIN_H_
diff --git a/media/capture/video/win/sink_filter_observer_win.h b/device/capture/video/win/sink_filter_observer_win.h
similarity index 75%
rename from media/capture/video/win/sink_filter_observer_win.h
rename to device/capture/video/win/sink_filter_observer_win.h
index 29842a7..1a7881cf 100644
--- a/media/capture/video/win/sink_filter_observer_win.h
+++ b/device/capture/video/win/sink_filter_observer_win.h
@@ -5,12 +5,12 @@
 // Observer class of Sinkfilter. The implementor of this class receive video
 // frames from the SinkFilter DirectShow filter.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_SINK_FILTER_OBSERVER_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_SINK_FILTER_OBSERVER_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_SINK_FILTER_OBSERVER_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_SINK_FILTER_OBSERVER_WIN_H_
 
 #include <stdint.h>
 
-namespace media {
+namespace device {
 
 class SinkFilterObserver {
  public:
@@ -24,6 +24,6 @@ class SinkFilterObserver {
   virtual ~SinkFilterObserver();
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_SINK_FILTER_OBSERVER_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_SINK_FILTER_OBSERVER_WIN_H_
diff --git a/media/capture/video/win/sink_filter_win.cc b/device/capture/video/win/sink_filter_win.cc
similarity index 92%
rename from media/capture/video/win/sink_filter_win.cc
rename to device/capture/video/win/sink_filter_win.cc
index 90c4ae0..2b5875b 100644
--- a/media/capture/video/win/sink_filter_win.cc
+++ b/device/capture/video/win/sink_filter_win.cc
@@ -2,12 +2,12 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/sink_filter_win.h"
+#include "device/capture/video/win/sink_filter_win.h"
 
 #include "base/logging.h"
-#include "media/capture/video/win/sink_input_pin_win.h"
+#include "device/capture/video/win/sink_input_pin_win.h"
 
-namespace media {
+namespace device {
 
 // Define GUID for I420. This is the color format we would like to support but
 // it is not defined in the DirectShow SDK.
@@ -60,4 +60,4 @@ SinkFilter::~SinkFilter() {
   input_pin_->SetOwner(NULL);
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/sink_filter_win.h b/device/capture/video/win/sink_filter_win.h
similarity index 82%
rename from media/capture/video/win/sink_filter_win.h
rename to device/capture/video/win/sink_filter_win.h
index 6c29eba..e7cc75e 100644
--- a/media/capture/video/win/sink_filter_win.h
+++ b/device/capture/video/win/sink_filter_win.h
@@ -5,20 +5,20 @@
 // Implement a DirectShow sink filter used for receiving captured frames from
 // a DirectShow Capture filter.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_SINK_FILTER_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_SINK_FILTER_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_SINK_FILTER_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_SINK_FILTER_WIN_H_
 
 #include <windows.h>
 #include <stddef.h>
 
 #include "base/macros.h"
 #include "base/memory/ref_counted.h"
+#include "device/capture/video/video_capture_device.h"
+#include "device/capture/video/win/filter_base_win.h"
+#include "device/capture/video/win/sink_filter_observer_win.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
-#include "media/capture/video/win/filter_base_win.h"
-#include "media/capture/video/win/sink_filter_observer_win.h"
 
-namespace media {
+namespace device {
 
 // Define GUID for I420. This is the color format we would like to support but
 // it is not defined in the DirectShow SDK.
@@ -59,6 +59,6 @@ class __declspec(uuid("88cdbbdc-a73b-4afa-acbf-15d5e2ce12c3")) SinkFilter
   DISALLOW_IMPLICIT_CONSTRUCTORS(SinkFilter);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_SINK_FILTER_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_SINK_FILTER_WIN_H_
diff --git a/media/capture/video/win/sink_input_pin_win.cc b/device/capture/video/win/sink_input_pin_win.cc
similarity index 91%
rename from media/capture/video/win/sink_input_pin_win.cc
rename to device/capture/video/win/sink_input_pin_win.cc
index 0abd0a7..929d334 100644
--- a/media/capture/video/win/sink_input_pin_win.cc
+++ b/device/capture/video/win/sink_input_pin_win.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/sink_input_pin_win.h"
+#include "device/capture/video/win/sink_input_pin_win.h"
 
 #include <cstring>
 
@@ -15,7 +15,7 @@
 #include "base/macros.h"
 #include "media/base/timestamp_constants.h"
 
-namespace media {
+namespace device {
 
 const REFERENCE_TIME kSecondsToReferenceTime = 10000000;
 
@@ -36,7 +36,7 @@ void SinkInputPin::SetRequestedMediaFormat(
   requested_info_header_ = info_header;
   resulting_format_.frame_size.SetSize(0, 0);
   resulting_format_.frame_rate = 0;
-  resulting_format_.pixel_format = PIXEL_FORMAT_UNKNOWN;
+  resulting_format_.pixel_format = media::PIXEL_FORMAT_UNKNOWN;
 }
 
 bool SinkInputPin::IsMediaTypeValid(const AM_MEDIA_TYPE* media_type) {
@@ -66,33 +66,33 @@ bool SinkInputPin::IsMediaTypeValid(const AM_MEDIA_TYPE* media_type) {
   }
   if (sub_type == kMediaSubTypeI420 &&
       pvi->bmiHeader.biCompression == MAKEFOURCC('I', '4', '2', '0')) {
-    resulting_format_.pixel_format = PIXEL_FORMAT_I420;
+    resulting_format_.pixel_format = media::PIXEL_FORMAT_I420;
     return true;
   }
   if (sub_type == MEDIASUBTYPE_YUY2 &&
       pvi->bmiHeader.biCompression == MAKEFOURCC('Y', 'U', 'Y', '2')) {
-    resulting_format_.pixel_format = PIXEL_FORMAT_YUY2;
+    resulting_format_.pixel_format = media::PIXEL_FORMAT_YUY2;
     return true;
   }
   // This format is added after http:/crbug.com/508413.
   if (sub_type == MEDIASUBTYPE_UYVY &&
       pvi->bmiHeader.biCompression == MAKEFOURCC('U', 'Y', 'V', 'Y')) {
-    resulting_format_.pixel_format = PIXEL_FORMAT_UYVY;
+    resulting_format_.pixel_format = media::PIXEL_FORMAT_UYVY;
     return true;
   }
   if (sub_type == MEDIASUBTYPE_MJPG &&
       pvi->bmiHeader.biCompression == MAKEFOURCC('M', 'J', 'P', 'G')) {
-    resulting_format_.pixel_format = PIXEL_FORMAT_MJPEG;
+    resulting_format_.pixel_format = media::PIXEL_FORMAT_MJPEG;
     return true;
   }
   if (sub_type == MEDIASUBTYPE_RGB24 &&
       pvi->bmiHeader.biCompression == BI_RGB) {
-    resulting_format_.pixel_format = PIXEL_FORMAT_RGB24;
+    resulting_format_.pixel_format = media::PIXEL_FORMAT_RGB24;
     return true;
   }
   if (sub_type == MEDIASUBTYPE_RGB32 &&
       pvi->bmiHeader.biCompression == BI_RGB) {
-    resulting_format_.pixel_format = PIXEL_FORMAT_RGB32;
+    resulting_format_.pixel_format = media::PIXEL_FORMAT_RGB32;
     return true;
   }
 
@@ -123,7 +123,7 @@ bool SinkInputPin::GetValidMediaType(int index, AM_MEDIA_TYPE* media_type) {
   media_type->formattype = FORMAT_VideoInfo;
   media_type->bTemporalCompression = FALSE;
 
-  if (requested_pixel_format_ == PIXEL_FORMAT_MJPEG) {
+  if (requested_pixel_format_ == media::PIXEL_FORMAT_MJPEG) {
     // If the requested pixel format is MJPEG, accept only MJPEG.
     // This is ok since the capabilities of the capturer have been
     // enumerated and we know that it is supported.
@@ -215,4 +215,4 @@ HRESULT SinkInputPin::Receive(IMediaSample* sample) {
 SinkInputPin::~SinkInputPin() {
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/sink_input_pin_win.h b/device/capture/video/win/sink_input_pin_win.h
similarity index 80%
rename from media/capture/video/win/sink_input_pin_win.h
rename to device/capture/video/win/sink_input_pin_win.h
index a88a333..669b8d2 100644
--- a/media/capture/video/win/sink_input_pin_win.h
+++ b/device/capture/video/win/sink_input_pin_win.h
@@ -5,16 +5,16 @@
 // Implement a DirectShow input pin used for receiving captured frames from
 // a DirectShow Capture filter.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_SINK_INPUT_PIN_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_SINK_INPUT_PIN_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_SINK_INPUT_PIN_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_SINK_INPUT_PIN_WIN_H_
 
 #include "base/macros.h"
+#include "device/capture/video/video_capture_device.h"
+#include "device/capture/video/win/pin_base_win.h"
+#include "device/capture/video/win/sink_filter_win.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
-#include "media/capture/video/win/pin_base_win.h"
-#include "media/capture/video/win/sink_filter_win.h"
 
-namespace media {
+namespace device {
 
 // Const used for converting Seconds to REFERENCE_TIME.
 extern const REFERENCE_TIME kSecondsToReferenceTime;
@@ -51,6 +51,6 @@ class SinkInputPin : public PinBase {
   DISALLOW_IMPLICIT_CONSTRUCTORS(SinkInputPin);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_SINK_INPUT_PIN_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_SINK_INPUT_PIN_WIN_H_
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/device/capture/video/win/video_capture_device_factory_win.cc
similarity index 98%
rename from media/capture/video/win/video_capture_device_factory_win.cc
rename to device/capture/video/win/video_capture_device_factory_win.cc
index 7f4c7a0..4a9b927 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/device/capture/video/win/video_capture_device_factory_win.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/video_capture_device_factory_win.h"
+#include "device/capture/video/win/video_capture_device_factory_win.h"
 
 #include <mfapi.h>
 #include <mferror.h>
@@ -16,10 +16,10 @@
 #include "base/win/scoped_co_mem.h"
 #include "base/win/scoped_variant.h"
 #include "base/win/windows_version.h"
+#include "device/capture/video/win/video_capture_device_mf_win.h"
+#include "device/capture/video/win/video_capture_device_win.h"
 #include "media/base/media_switches.h"
 #include "media/base/win/mf_initializer.h"
-#include "media/capture/video/win/video_capture_device_mf_win.h"
-#include "media/capture/video/win/video_capture_device_win.h"
 
 using base::win::ScopedCoMem;
 using base::win::ScopedComPtr;
@@ -27,7 +27,7 @@ using base::win::ScopedVariant;
 using Descriptor = media::VideoCaptureDeviceDescriptor;
 using Descriptors = media::VideoCaptureDeviceDescriptors;
 
-namespace media {
+namespace device {
 
 // In Windows device identifiers, the USB VID and PID are preceded by the string
 // "vid_" or "pid_".  The identifiers are each 4 bytes long.
@@ -309,7 +309,7 @@ static void GetDeviceSupportedFormatsDirectShow(const Descriptor& descriptor,
       format.pixel_format =
           VideoCaptureDeviceWin::TranslateMediaSubtypeToPixelFormat(
               media_type->subtype);
-      if (format.pixel_format == PIXEL_FORMAT_UNKNOWN)
+      if (format.pixel_format == media::PIXEL_FORMAT_UNKNOWN)
         continue;
       VIDEOINFOHEADER* h =
           reinterpret_cast<VIDEOINFOHEADER*>(media_type->pbFormat);
@@ -463,4 +463,4 @@ VideoCaptureDeviceFactory::CreateVideoCaptureDeviceFactory(
   return new VideoCaptureDeviceFactoryWin();
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/video_capture_device_factory_win.h b/device/capture/video/win/video_capture_device_factory_win.h
similarity index 79%
rename from media/capture/video/win/video_capture_device_factory_win.h
rename to device/capture/video/win/video_capture_device_factory_win.h
index 9afcc64..6247c57 100644
--- a/media/capture/video/win/video_capture_device_factory_win.h
+++ b/device/capture/video/win/video_capture_device_factory_win.h
@@ -4,13 +4,13 @@
 
 // Implementation of a VideoCaptureDeviceFactory class for Windows platforms.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_FACTORY_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_FACTORY_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_FACTORY_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_FACTORY_WIN_H_
 
 #include "base/macros.h"
-#include "media/capture/video/video_capture_device_factory.h"
+#include "device/capture/video/video_capture_device_factory.h"
 
-namespace media {
+namespace device {
 
 // Extension of VideoCaptureDeviceFactory to create and manipulate Windows
 // devices, via either DirectShow or MediaFoundation APIs.
@@ -38,6 +38,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceFactoryWin
   DISALLOW_COPY_AND_ASSIGN(VideoCaptureDeviceFactoryWin);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_FACTORY_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_FACTORY_WIN_H_
diff --git a/media/capture/video/win/video_capture_device_mf_win.cc b/device/capture/video/win/video_capture_device_mf_win.cc
similarity index 94%
rename from media/capture/video/win/video_capture_device_mf_win.cc
rename to device/capture/video/win/video_capture_device_mf_win.cc
index 9965e7c..4833e71 100644
--- a/media/capture/video/win/video_capture_device_mf_win.cc
+++ b/device/capture/video/win/video_capture_device_mf_win.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/video_capture_device_mf_win.h"
+#include "device/capture/video/win/video_capture_device_mf_win.h"
 
 #include <mfapi.h>
 #include <mferror.h>
@@ -17,12 +17,12 @@
 #include "base/synchronization/waitable_event.h"
 #include "base/win/scoped_co_mem.h"
 #include "base/win/windows_version.h"
-#include "media/capture/video/win/capability_list_win.h"
+#include "device/capture/video/win/capability_list_win.h"
 
 using base::win::ScopedCoMem;
 using base::win::ScopedComPtr;
 
-namespace media {
+namespace device {
 
 static bool GetFrameSize(IMFMediaType* type, gfx::Size* frame_size) {
   UINT32 width32, height32;
@@ -163,13 +163,13 @@ bool VideoCaptureDeviceMFWin::FormatFromGuid(const GUID& guid,
     const GUID& guid;
     const VideoPixelFormat format;
   } static const kFormatMap[] = {
-      {MFVideoFormat_I420, PIXEL_FORMAT_I420},
-      {MFVideoFormat_YUY2, PIXEL_FORMAT_YUY2},
-      {MFVideoFormat_UYVY, PIXEL_FORMAT_UYVY},
-      {MFVideoFormat_RGB24, PIXEL_FORMAT_RGB24},
-      {MFVideoFormat_ARGB32, PIXEL_FORMAT_ARGB},
-      {MFVideoFormat_MJPG, PIXEL_FORMAT_MJPEG},
-      {MFVideoFormat_YV12, PIXEL_FORMAT_YV12},
+      {MFVideoFormat_I420, media::PIXEL_FORMAT_I420},
+      {MFVideoFormat_YUY2, media::PIXEL_FORMAT_YUY2},
+      {MFVideoFormat_UYVY, media::PIXEL_FORMAT_UYVY},
+      {MFVideoFormat_RGB24, media::PIXEL_FORMAT_RGB24},
+      {MFVideoFormat_ARGB32, media::PIXEL_FORMAT_ARGB},
+      {MFVideoFormat_MJPG, media::PIXEL_FORMAT_MJPEG},
+      {MFVideoFormat_YV12, media::PIXEL_FORMAT_YV12},
   };
 
   for (const auto& kFormat : kFormatMap) {
@@ -312,4 +312,4 @@ void VideoCaptureDeviceMFWin::OnError(
   }
 }
 
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/video_capture_device_mf_win.h b/device/capture/video/win/video_capture_device_mf_win.h
similarity index 87%
rename from media/capture/video/win/video_capture_device_mf_win.h
rename to device/capture/video/win/video_capture_device_mf_win.h
index 68cd4f8..3a1d99e 100644
--- a/media/capture/video/win/video_capture_device_mf_win.h
+++ b/device/capture/video/win/video_capture_device_mf_win.h
@@ -6,8 +6,8 @@
 // DirectShow is used for capturing. DirectShow provide its own threads
 // for capturing.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_MF_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_MF_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_MF_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_MF_WIN_H_
 
 #include <mfidl.h>
 #include <mfreadwrite.h>
@@ -19,8 +19,8 @@
 #include "base/synchronization/lock.h"
 #include "base/threading/non_thread_safe.h"
 #include "base/win/scoped_comptr.h"
-#include "media/capture/capture_export.h"
-#include "media/capture/video/video_capture_device.h"
+#include "device/capture/capture_export.h"
+#include "device/capture/video/video_capture_device.h"
 
 interface IMFSourceReader;
 
@@ -28,7 +28,7 @@ namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
+namespace device {
 
 class MFReaderCallback;
 
@@ -76,6 +76,6 @@ class CAPTURE_EXPORT VideoCaptureDeviceMFWin : public base::NonThreadSafe,
   DISALLOW_IMPLICIT_CONSTRUCTORS(VideoCaptureDeviceMFWin);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_MF_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_MF_WIN_H_
diff --git a/media/capture/video/win/video_capture_device_win.cc b/device/capture/video/win/video_capture_device_win.cc
similarity index 96%
rename from media/capture/video/win/video_capture_device_win.cc
rename to device/capture/video/win/video_capture_device_win.cc
index d3c5d53..65b9ff0 100644
--- a/media/capture/video/win/video_capture_device_win.cc
+++ b/device/capture/video/win/video_capture_device_win.cc
@@ -2,7 +2,7 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
-#include "media/capture/video/win/video_capture_device_win.h"
+#include "device/capture/video/win/video_capture_device_win.h"
 
 #include <ks.h>
 #include <ksmedia.h>
@@ -21,7 +21,7 @@ using base::win::ScopedCoMem;
 using base::win::ScopedComPtr;
 using base::win::ScopedVariant;
 
-namespace media {
+namespace device {
 
 // Check if a Pin matches a category.
 bool PinMatchesCategory(IPin* pin, REFGUID category) {
@@ -150,14 +150,14 @@ VideoCaptureDeviceWin::TranslateMediaSubtypeToPixelFormat(
     const GUID& sub_type;
     VideoPixelFormat format;
   } const kMediaSubtypeToPixelFormatCorrespondence[] = {
-      {kMediaSubTypeI420, PIXEL_FORMAT_I420},
-      {MEDIASUBTYPE_IYUV, PIXEL_FORMAT_I420},
-      {MEDIASUBTYPE_RGB24, PIXEL_FORMAT_RGB24},
-      {MEDIASUBTYPE_YUY2, PIXEL_FORMAT_YUY2},
-      {MEDIASUBTYPE_MJPG, PIXEL_FORMAT_MJPEG},
-      {MEDIASUBTYPE_UYVY, PIXEL_FORMAT_UYVY},
-      {MEDIASUBTYPE_ARGB32, PIXEL_FORMAT_ARGB},
-      {kMediaSubTypeHDYC, PIXEL_FORMAT_UYVY},
+      {kMediaSubTypeI420, media::PIXEL_FORMAT_I420},
+      {MEDIASUBTYPE_IYUV, media::PIXEL_FORMAT_I420},
+      {MEDIASUBTYPE_RGB24, media::PIXEL_FORMAT_RGB24},
+      {MEDIASUBTYPE_YUY2, media::PIXEL_FORMAT_YUY2},
+      {MEDIASUBTYPE_MJPG, media::PIXEL_FORMAT_MJPEG},
+      {MEDIASUBTYPE_UYVY, media::PIXEL_FORMAT_UYVY},
+      {MEDIASUBTYPE_ARGB32, media::PIXEL_FORMAT_ARGB},
+      {kMediaSubTypeHDYC, media::PIXEL_FORMAT_UYVY},
   };
   for (const auto& pixel_format : kMediaSubtypeToPixelFormatCorrespondence) {
     if (sub_type == pixel_format.sub_type)
@@ -168,7 +168,7 @@ VideoCaptureDeviceWin::TranslateMediaSubtypeToPixelFormat(
   StringFromGUID2(sub_type, guid_str, arraysize(guid_str));
   DVLOG(2) << "Device (also) supports an unknown media type " << guid_str;
 #endif
-  return PIXEL_FORMAT_UNKNOWN;
+  return media::PIXEL_FORMAT_UNKNOWN;
 }
 
 void VideoCaptureDeviceWin::ScopedMediaType::Free() {
@@ -508,7 +508,7 @@ bool VideoCaptureDeviceWin::CreateCapabilityMap() {
       VideoCaptureFormat format;
       format.pixel_format =
           TranslateMediaSubtypeToPixelFormat(media_type->subtype);
-      if (format.pixel_format == PIXEL_FORMAT_UNKNOWN)
+      if (format.pixel_format == media::PIXEL_FORMAT_UNKNOWN)
         continue;
 
       VIDEOINFOHEADER* h =
@@ -551,7 +551,8 @@ bool VideoCaptureDeviceWin::CreateCapabilityMap() {
 // Set the power line frequency removal in |capture_filter_| if available.
 void VideoCaptureDeviceWin::SetAntiFlickerInCaptureFilter(
     const VideoCaptureParams& params) {
-  const PowerLineFrequency power_line_frequency = GetPowerLineFrequency(params);
+  const media::PowerLineFrequency power_line_frequency =
+      GetPowerLineFrequency(params);
   if (power_line_frequency != media::PowerLineFrequency::FREQUENCY_50HZ &&
       power_line_frequency != media::PowerLineFrequency::FREQUENCY_60HZ) {
     return;
@@ -591,4 +592,4 @@ void VideoCaptureDeviceWin::SetErrorState(
   state_ = kError;
   client_->OnError(from_here, reason);
 }
-}  // namespace media
+}  // namespace device
diff --git a/media/capture/video/win/video_capture_device_win.h b/device/capture/video/win/video_capture_device_win.h
similarity index 89%
rename from media/capture/video/win/video_capture_device_win.h
rename to device/capture/video/win/video_capture_device_win.h
index 12ae25b..81cd492 100644
--- a/media/capture/video/win/video_capture_device_win.h
+++ b/device/capture/video/win/video_capture_device_win.h
@@ -5,8 +5,8 @@
 // Windows specific implementation of VideoCaptureDevice. DirectShow is used for
 // capturing. DirectShow provide its own threads for capturing.
 
-#ifndef MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_WIN_H_
-#define MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_WIN_H_
+#ifndef DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_WIN_H_
+#define DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_WIN_H_
 
 // Avoid including strsafe.h via dshow as it will cause build warnings.
 #define NO_DSHOW_STRSAFE
@@ -19,17 +19,17 @@
 #include "base/macros.h"
 #include "base/threading/thread_checker.h"
 #include "base/win/scoped_comptr.h"
+#include "device/capture/video/video_capture_device.h"
+#include "device/capture/video/win/capability_list_win.h"
+#include "device/capture/video/win/sink_filter_win.h"
+#include "device/capture/video/win/sink_input_pin_win.h"
 #include "media/base/video_capture_types.h"
-#include "media/capture/video/video_capture_device.h"
-#include "media/capture/video/win/capability_list_win.h"
-#include "media/capture/video/win/sink_filter_win.h"
-#include "media/capture/video/win/sink_input_pin_win.h"
 
 namespace tracked_objects {
 class Location;
 }  // namespace tracked_objects
 
-namespace media {
+namespace device {
 
 // All the methods in the class can only be run on a COM initialized thread.
 class VideoCaptureDeviceWin : public VideoCaptureDevice,
@@ -120,6 +120,6 @@ class VideoCaptureDeviceWin : public VideoCaptureDevice,
   DISALLOW_IMPLICIT_CONSTRUCTORS(VideoCaptureDeviceWin);
 };
 
-}  // namespace media
+}  // namespace device
 
-#endif  // MEDIA_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_WIN_H_
+#endif  // DEVICE_CAPTURE_VIDEO_WIN_VIDEO_CAPTURE_DEVICE_WIN_H_
diff --git a/media/base/BUILD.gn b/media/base/BUILD.gn
index 6e74b68..77331a5 100644
--- a/media/base/BUILD.gn
+++ b/media/base/BUILD.gn
@@ -29,7 +29,7 @@ if (is_component_build) {
 }
 target(link_target_type, "base") {
   # This is part of the media component.
-  visibility = [ "//media/*" ]
+  #visibility = [ "//media/*" ]
   sources = [
     "audio_block_fifo.cc",
     "audio_block_fifo.h",
diff --git a/media/base/media_switches.cc b/media/base/media_switches.cc
index 16c3355..2de2cdf 100644
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -93,7 +93,7 @@ const char kEnableDefaultMediaSession[] = "enable-default-media-session";
 const char kUseFakeDeviceForMediaStream[] = "use-fake-device-for-media-stream";
 
 // Use an .y4m file to play as the webcam. See the comments in
-// media/capture/video/file_video_capture_device.h for more details.
+// device/capture/video/file_video_capture_device.h for more details.
 const char kUseFileForFakeVideoCapture[] = "use-file-for-fake-video-capture";
 
 // Play a .wav file as the microphone. Note that for WebRTC calls we'll treat
diff --git a/media/capture/content/android/BUILD.gn b/media/capture/content/android/BUILD.gn
deleted file mode 100644
index 3030b39..0000000
--- a/media/capture/content/android/BUILD.gn
+++ /dev/null
@@ -1,43 +0,0 @@
-# Copyright 2016 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-import("//build/config/android/config.gni")
-import("//build/config/android/rules.gni")
-import("//build/config/arm.gni")
-import("//build/config/ui.gni")
-import("//media/media_options.gni")
-
-assert(is_android)
-
-source_set("android") {
-  sources = [
-    "screen_capture_jni_registrar.cc",
-    "screen_capture_jni_registrar.h",
-    "screen_capture_machine_android.cc",
-    "screen_capture_machine_android.h",
-  ]
-  configs += [
-    "//media:media_config",
-    "//media:media_implementation",
-  ]
-  deps = [
-    ":screen_capture_jni_headers",
-    "//media/mojo/interfaces:image_capture",
-    "//third_party/libyuv",
-  ]
-}
-
-generate_jni("screen_capture_jni_headers") {
-  sources = [
-    "java/src/org/chromium/media/ScreenCapture.java",
-  ]
-  jni_package = "media"
-}
-
-android_library("screen_capture_java") {
-  deps = [
-    "//base:base_java",
-  ]
-  java_files = [ "java/src/org/chromium/media/ScreenCapture.java" ]
-}
diff --git a/media/capture/content/android/screen_capture_jni_registrar.h b/media/capture/content/android/screen_capture_jni_registrar.h
deleted file mode 100644
index 71e4af4..0000000
--- a/media/capture/content/android/screen_capture_jni_registrar.h
+++ /dev/null
@@ -1,17 +0,0 @@
-// Copyright 2016 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef MEDIA_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_JNI_REGISTRAR_H_
-#define MEDIA_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_JNI_REGISTRAR_H_
-
-#include <jni.h>
-
-namespace media {
-
-// Register all JNI bindings necessary for screen capture.
-bool RegisterScreenCaptureJni(JNIEnv* env);
-
-}  // namespace media
-
-#endif  // MEDIA_CAPTURE_CONTENT_ANDROID_SCREEN_CAPTURE_JNI_REGISTRAR_H_
diff --git a/media/capture/video/DEPS b/media/capture/video/DEPS
deleted file mode 100644
index 896f509..0000000
--- a/media/capture/video/DEPS
+++ /dev/null
@@ -1,3 +0,0 @@
-include_rules = [
-  "+mojo/public/cpp/bindings",
-]
\ No newline at end of file
diff --git a/media/capture/video/android/BUILD.gn b/media/capture/video/android/BUILD.gn
deleted file mode 100644
index 3dbc7f4..0000000
--- a/media/capture/video/android/BUILD.gn
+++ /dev/null
@@ -1,69 +0,0 @@
-# Copyright 2016 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-import("//build/config/android/config.gni")
-import("//build/config/android/rules.gni")
-import("//build/config/arm.gni")
-import("//build/config/ui.gni")
-import("//media/media_options.gni")
-
-assert(is_android)
-
-source_set("android") {
-  sources = [
-    "capture_jni_registrar.cc",
-    "capture_jni_registrar.h",
-    "photo_capabilities.cc",
-    "photo_capabilities.h",
-    "video_capture_device_android.cc",
-    "video_capture_device_android.h",
-    "video_capture_device_factory_android.cc",
-    "video_capture_device_factory_android.h",
-  ]
-  configs += [
-    "//media:media_config",
-    "//media:media_implementation",
-  ]
-  deps = [
-    ":capture_jni_headers",
-    "//media/mojo/interfaces:image_capture",
-    "//third_party/libyuv",
-  ]
-}
-
-generate_jni("capture_jni_headers") {
-  sources = [
-    "java/src/org/chromium/media/PhotoCapabilities.java",
-    "java/src/org/chromium/media/VideoCapture.java",
-    "java/src/org/chromium/media/VideoCaptureFactory.java",
-  ]
-  jni_package = "media"
-}
-
-java_cpp_enum("media_java_enums_srcjar") {
-  sources = [
-    "../video_capture_device_descriptor.h",
-    "video_capture_device_android.h",
-  ]
-}
-
-android_library("capture_java") {
-  deps = [
-    "//base:base_java",
-    "//third_party/android_tools:android_support_annotations_java",
-  ]
-
-  srcjar_deps = [ ":media_java_enums_srcjar" ]
-
-  java_files = [
-    "java/src/org/chromium/media/PhotoCapabilities.java",
-    "java/src/org/chromium/media/VideoCapture.java",
-    "java/src/org/chromium/media/VideoCaptureAndroid.java",
-    "java/src/org/chromium/media/VideoCaptureCamera.java",
-    "java/src/org/chromium/media/VideoCaptureCamera2.java",
-    "java/src/org/chromium/media/VideoCaptureFactory.java",
-    "java/src/org/chromium/media/VideoCaptureFormat.java",
-    "java/src/org/chromium/media/VideoCaptureTango.java",
-  ]
-}
