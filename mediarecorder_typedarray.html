<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>TypedArray MediaStream Recoder demo (w/ MediaSource)</title>
</head>
<body>
</body>

<script>
/* global Blob */
/* global MediaRecorder */
/* global MediaSource */
/* global URL */

var recorder;
var theStream;

// Idea from: http://codepen.io/anon/pen/gpmPzm?editors=101, stuff received 
// data in |chunks|, then blobify it and plug the result in a <video> .
// This does not seem to work.
//
// The alternative is, e.g. [1, 2], using MediaSource where we basically pass 
// recorded chunks one by one into a MediaSource associated to a <video>.
// MediaRecorder supposedly produces BlobEvents and Blobs are not friendly to 
// MediaSource-SourceBuffer, so there's an Experimental CL sending stuff as 
// an Uint8ArrayEvent.
//
// [1] http://html5-demos.appspot.com/static/media-source.html
// [2] https://github.com/html5rocks/www.html5rocks.com/blob/master/content/tutorials/streaming/multimedia/en/index.md
var recordedBytes = new Uint8Array(1000000);
var numRecordedBytes = 0;

var mediaSource = new MediaSource();
var sourceBuffer;
function mediaSourceOpened(e) {
  console.log('MediaSource opened correctly');
  sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
}
mediaSource.addEventListener('sourceopen', mediaSourceOpened, false);

function createButton(id, text, onClick) {
  const button = document.createElement("input");
  button.id = id;
  button.type = "button";
  button.value = text;
  button.onclick = onClick;
  document.body.appendChild(button);
  console.log("Button " + id + " created");
}

function createVideoTag(id, width, height, video_source) {
  const videoTag = document.createElement('video');
  if (video_source != '')
    videoTag.src = URL.createObjectURL(video_source);
  videoTag.id = id;
  videoTag.height = height;
  videoTag.width = width;
  document.body.appendChild(videoTag);
  videoTag.autoplay = true;
  console.log("VideoTag " + id + " created");
}
createVideoTag('localview', 80, 60, '');
createVideoTag('video', 320, 240, mediaSource);
document.body.appendChild(document.createElement("br"));

////////////////////////////////////////////////////////////////////////////////
function getUserMediaFailedCallback(error) {
  console.error('User media request denied with error code ' + error.code);
}

function getUserMediaOkCallback(stream) {
  console.log("getUserMedia succeeded :)");
  theStream = stream;
  document.getElementById("localview").src = URL.createObjectURL(stream);
  createButton("btn2", "Stop recording and play back", stopStreamsAndPlaybackData);

  try {
    recorder = new MediaRecorder(stream, "video/vp8");
  } catch (e) {
    console.assert(false, 'Exception while creating MediaRecorder: ' + e);
    return;
  }
  console.assert(recorder.state == "inactive");
  recorder.ondataavailable = recorderOnDataAvailable;
  recorder.onstop = recorderOnStop;
  recorder.start(); 
  console.log("Recorder is started");
  console.assert(recorder.state == "recording");
}

function recorderOnDataAvailable(event) {
  if (event)
    console.assert(event.data.length > 0, 'Recorded data size should be > 0');
  console.assert(recorder.state == "recording", "State should be 'recording'");

  if (event.data.byteLength < 10)
    console.log("data: " + event.data);

  // Use |byteLength| instead of |length| for event.data;
  recordedBytes.set(event.data, numRecordedBytes);
  numRecordedBytes += event.data.byteLength;
}

function recorderOnStop() {
  console.log('recorderOnStop fired');
}

function saveByteArray(data, name) {
  var blob = new Blob(data, {type: "video/webm"});
  var url = URL.createObjectURL(blob);
  var a = document.createElement("a");
  document.body.appendChild(a);
  a.style = "display: none";
  a.href = url;
  a.download = name;
  a.click();
  URL.revokeObjectURL(url);
}

function stopStreamsAndPlaybackData() {
  document.getElementById("btn").disabled = true;
  document.getElementById("btn2").disabled = true;
  console.log('Stopping record and starting playback');
  recorder.stop();

  theStream.getVideoTracks()[0].stop();
  
  // sourceBuffer.appendBuffer(recordedBytes);
  // Or...
  // var superBuffer = new Blob(recordedBytes);
  // document.getElementById("video").src = window.URL.createObjectURL(superBuffer);
  // Or ...
  saveByteArray(recordedBytes, 'test.webm')();
}

function startTheParty() {
  navigator.webkitGetUserMedia({audio: false, "video": { "mandatory": { "minWidth": 320, "maxWidth": 320, "minHeight": 240, "maxHeight": 240 }}},
                               getUserMediaOkCallback,
                               getUserMediaFailedCallback);
}
createButton("btn", "Start recording", startTheParty);
</script>
</html>
